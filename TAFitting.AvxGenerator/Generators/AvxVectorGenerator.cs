
// (c) 2024 Kazuki Kohzuki

namespace TAFitting.IntrinsicsGenerator.Generators;

[Generator(LanguageNames.CSharp)]
internal sealed class AvxVectorGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new AttributeSyntaxReceiver(AvxVectorAttributesGenerator.AttributeName));
    } // public void Initialize (GeneratorInitializationContext)

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not AttributeSyntaxReceiver receiver) return;

        foreach (var declaration in receiver.Vectors)
        {
            try
            {
                var klass = declaration.Target;
                var attr = declaration.Attribute;

                (var nameSpace, var className) = GetFullyQualifiedName(context, klass);
                var count = GetCount(context, attr);
                var source = Generate(nameSpace, className, count);
                var fileName = $"{className}.g.cs";
                context.AddSource(fileName, source);
            }
            catch
            {

            }
        }
    } // public void Execute (GeneratorExecutionContext)

    private static string Generate(string nameSpace, string className, int count)
    {
        var n = count / 4;

        var builder = new StringBuilder();

        builder.AppendLine("// <auto-generated/>");
        builder.AppendLine();
        builder.AppendLine("using System.Runtime.Intrinsics;");
        builder.AppendLine("using System.Runtime.Intrinsics.X86;");
        if (!nameSpace.StartsWith("TAFitting.Data"))
            builder.AppendLine("using TAFitting.Data;");

        if (!string.IsNullOrEmpty(nameSpace))
        {
            builder.AppendLine();
            builder.AppendLine($"namespace {nameSpace};");
        }

        builder.AppendLine();
        builder.AppendLine($"/// <summary>");
        builder.AppendLine($"/// An AVX vector of {count} elements.");
        builder.AppendLine($"/// </summary>");
        builder.AppendLine($"internal partial class {className} : IIntrinsicVector<{className}>");
        builder.AppendLine("{");

        builder.AppendLine("private static readonly bool isSupported = Avx.IsSupported && Vector256<double>.IsSupported;");

        builder.AppendLine();
        builder.AppendLine("#region static properties");

        builder.AppendLine();
        builder.AppendLine("\t///");
        builder.AppendLine("\t/// Gets a value indicating whether the AVX instruction set is supported.");
        builder.AppendLine("\t///");
        builder.AppendLine("\t/// <value><see langword=\"true\"/> if the AVX instruction set is supported; otherwise, <see langword=\"false\"/>.</value>");
        builder.AppendLine("\tinternal static bool IsSupported => isSupported;");

        builder.AppendLine();
        builder.AppendLine("\t///");
        builder.AppendLine("\t/// Gets the capacity of the vector.");
        builder.AppendLine("\t///");
        builder.AppendLine("\tinternal static int Capacity => " + count + ";");
        builder.AppendLine();
        builder.AppendLine("#endregion static properties");

        builder.AppendLine();
        builder.AppendLine("#region instance fields");

        builder.AppendLine();
        builder.AppendLine("\tprivate readonly int count;");
        foreach (var element in GenerateElements(n, 16, x => $"v{x}", ", "))
            builder.AppendLine($"\tprivate Vector256<double> {element};");
        builder.AppendLine();
        builder.AppendLine("#endregion instance fields");

        builder.AppendLine();
        builder.AppendLine("#region instance properties");

        builder.AppendLine();
        builder.AppendLine("\t/// <summary>");
        builder.AppendLine("\t/// Gets the number of elements.");
        builder.AppendLine("\t/// </summary>");
        builder.AppendLine("\tinternal int Length => " + count + ";");

        builder.AppendLine();
        builder.AppendLine("\tpublic double Sum");
        builder.AppendLine("\t{");
        builder.AppendLine("\t\tget");
        builder.AppendLine("\t\t{");
        builder.AppendLine("\t\t\tvar acc = Vector256<double>.Zero;");
        foreach (var element in GenerateElements(n, 4, x => $"acc = Avx.Add(acc, this.v{x})", "; "))
            builder.AppendLine($"\t\t\t{element};");
        builder.AppendLine();
        builder.AppendLine("\t\t\treturn acc.GetElement(0) + acc.GetElement(1) + acc.GetElement(2) + acc.GetElement(3);");
        builder.AppendLine("\t\t}");
        builder.AppendLine("\t}");
        builder.AppendLine();
        builder.AppendLine("#endregion instance properties");

        builder.AppendLine();
        builder.AppendLine("#region constructors");

        builder.AppendLine();
        builder.AppendLine("\t/// <summary>");
        builder.AppendLine("\t/// Initializes a new instance of the <see cref=\"AvxVector\"/> class with the specified values.");
        builder.AppendLine("\t/// </summary>");
        builder.AppendLine("\t/// <param name=\"values\">The values.</param>");
        builder.AppendLine($"\tunsafe internal {className}(double[] values)");
        builder.AppendLine("\t{");
        builder.AppendLine($"\t\tthis.count = Math.Min(values.Length >> 2, {n});");
        builder.AppendLine("\t\tfixed (double* p = values)");
        builder.AppendLine("\t\t{");
        foreach (var element in GenerateElements(n, 4, x => $"this.v{x} = Avx.LoadVector256(p + {4 * x})", "; "))
            builder.AppendLine($"\t\t\t{element};");
        builder.AppendLine("\t\t}");
        builder.AppendLine("\t} // ctor (IReadOnlyList<double>)");

        builder.AppendLine();
        builder.AppendLine("\t/// <summary>");
        builder.AppendLine("\t/// Initializes a new instance of the <see cref=\"AvxVector\"/> class with the specified length.");
        builder.AppendLine("\t/// </summary>");
        builder.AppendLine("\t/// <param name=\"length\">The length.</param>");
        builder.AppendLine($"\tinternal {className}(int length)");
        builder.AppendLine("\t{");
        builder.AppendLine($"\t\tthis.count = Math.Min(length >> 2, {n});");
        foreach (var element in GenerateElements(n, 4, x => $"this.v{x} = Vector256<double>.Zero", "; "))
            builder.AppendLine($"\t\t{element};");
        builder.AppendLine("\t} // ctor (int)");

        builder.AppendLine();
        builder.AppendLine("\t/// <summary>");
        builder.AppendLine("\t/// Initializes a new instance of the <see cref=\"AvxVector\"/> class with the specified vectors.");
        builder.AppendLine("\t/// </summary>");
        builder.AppendLine("\t/// <param name=\"count\">The count.</param>");
        builder.AppendLine("\t/// <param name=\"vectors\">The vectors.</param>");
        builder.AppendLine($"\tprivate {className}(int count, ReadOnlySpan<Vector256<double>> vectors)");
        builder.AppendLine("\t{");
        builder.AppendLine("\t\tthis.count = count;");
        foreach (var element in GenerateElements(n, 4, x => $"this.v{x} = vectors[{x}]", "; "))
            builder.AppendLine($"\t\t{element};");
        builder.AppendLine("\t} // ctor (int, ReadOnlySpan<Vector256<double>>)");
        builder.AppendLine();
        builder.AppendLine("#endregion constructors");

        builder.AppendLine();
        builder.AppendLine($"#region IIntrinsicVector<{className}>");

        builder.AppendLine();
        builder.AppendLine($"\tpublic static {className} Create(double[] values)");
        builder.AppendLine("\t\t=> new(values);");

        builder.AppendLine();
        builder.AppendLine($"\tpublic static {className} Create(int length)");
        builder.AppendLine("\t\t=> new(length);");

        builder.AppendLine();
        builder.AppendLine("\tpublic static int GetCapacity()");
        builder.AppendLine("\t\t=> Capacity;");

        builder.AppendLine();
        builder.AppendLine("public static bool CheckSupported()");
        builder.AppendLine("\t\t=> IsSupported;");

        builder.AppendLine();
        builder.AppendLine($"#endregion IIntrinsicVector<{className}>");

        builder.AppendLine();
        builder.AppendLine("#region operators");

        AddOperator(builder, className, "+", "Add", n);
        AddOperator(builder, className, "-", "Subtract", n);
        AddOperator(builder, className, "*", "Multiply", n);
        AddOperator(builder, className, "/", "Divide", n);

        builder.AppendLine();
        builder.AppendLine("#endregion operators");

        builder.AppendLine($"}} // internal partial class {className} : IIntrinsicVector<{className}>");

        return builder.ToString();
    } // private static string Generate (string, string, int)

    private static IEnumerable<string> GenerateElements(int n, int elementsInLine, Func<int, string> func, string separator)
    {
        for (var i = 0; i < n; i += elementsInLine)
        {
            var start = i;
            var end = Math.Min(i + elementsInLine, n);
            var elements = string.Join(separator, Enumerable.Range(start, end - start).Select(func));
            yield return elements;
        }
    } // private static IEnumerable<string> GenerateElements (int, int, Func<int, string>, string)

    private static void AddOperator(StringBuilder builder, string className, string op, string method, int n)
    {
        builder.AppendLine();
        builder.AppendLine($"\tpublic static {className} operator {op}({className} a, {className} b)");
        builder.AppendLine("\t{");
        builder.AppendLine("\t\tif (a.count != b.count)");
        builder.AppendLine("\t\t\tthrow new ArgumentException(\"The count of the vectors must be the same.\");");
        builder.AppendLine();
        builder.AppendLine($"\t\tvar ret = new {className}(a.count << 2);");
        foreach (var element in GenerateElements(n, 4, x => $"ret.v{x} = Avx.{method}(a.v{x}, b.v{x})", "; "))
            builder.AppendLine($"\t\t{element};");
        builder.AppendLine();
        builder.AppendLine("\t\treturn ret;");
        builder.AppendLine($"\t}} // public static {className} operator {op}({className}, {className})");
    } // private static void AddOperator (string, string, int)

    private static int GetCount(GeneratorExecutionContext context, AttributeSyntax attribute)
    {
        var args = attribute.ArgumentList?.Arguments.Cast<AttributeArgumentSyntax>();

        var orderArg = args?.FirstOrDefault()?.Expression
            ?? throw new Exception("Failed to get the order parameter of the model.");
        if (context.Compilation.GetSemanticModel(attribute.SyntaxTree).GetConstantValue(orderArg).Value is not int c)
            throw new Exception("Failed to get the order parameter of the model.");
        return c;
    } // private static int GetCount (GeneratorExecutionContext, AttributeSyntax)

    /// <summary>
    /// Gets the fully qualified name of the class.
    /// </summary>
    /// <param name="context">The context</param>
    /// <param name="klass">The class declaration syntax.</param>
    /// <returns>The fully qualified name of the class.</returns>
    /// <exception cref="Exception">Failed to get the symbol of the class.</exception>
    private static (string, string) GetFullyQualifiedName(GeneratorExecutionContext context, ClassDeclarationSyntax klass)
    {
        var typeSymbol =
            context.Compilation
                   .GetSemanticModel(klass.SyntaxTree)
                   .GetDeclaredSymbol(klass)
            ?? throw new Exception("Failed to get the symbol of the class.");
        var nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
        var className = typeSymbol.Name;
        return (nameSpace, className);
    } // protected virtual (string, string) GetFullyQualifiedName (GeneratorExecutionContext, ClassDeclarationSyntax)
} // internal sealed class AvxVectorGenerator : ISourceGenerator
