
// (c) 2025 Kazuki Kohzuki

using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.Intrinsics;
using System.Runtime.Intrinsics.X86;

#pragma warning disable IDE0130

namespace TAFitting.Data;

#pragma warning restore

/// <summary>
/// Provides mathematical functions.
/// </summary>
file static class MathUtils
{
    private static readonly Vector256<double> ExpMin, ExpMax;
    private static readonly Vector256<double> Alpha, AlphaInv;
    private static readonly Vector256<double> C1, C2, C3;
    private static readonly Vector256<double> Round;
    private static readonly Vector256<ulong> Mask11;
    private static readonly Vector256<ulong> Adj;

    /*
     * To calculate the i-th element of the table, use the following formula:
     * 
     *  1. Calculate x = Math.Pow(2, i * (1.0 / s)) where s is the number of elements in the table (2048).
     *  2. Interpret x as a 64-bit unsigned integer.
     *  3. Take lower 52 bits of x.
     * 
     * These calculations are done ahead-of-time and hardcoded to improve performance.
     */
    private static readonly ulong[] exp_table = [
        0UL, 1524504739922UL, 3049525536975UL, 4575062565848UL, 6101116001290UL, 7627686018109UL, 9154772791171UL, 10682376495403UL,
        12210497305791UL, 13739135397378UL, 15268290945269UL, 16797964124627UL, 18328155110673UL, 19858864078691UL, 21390091204021UL, 22921836662063UL,
        24454100628277UL, 25986883278183UL, 27520184787359UL, 29054005331443UL, 30588345086132UL, 32123204227184UL, 33658582930415UL, 35194481371701UL,
        36730899726977UL, 38267838172239UL, 39805296883541UL, 41343276036997UL, 42881775808782UL, 44420796375129UL, 45960337912330UL, 47500400596739UL,
        49040984604769UL, 50582090112891UL, 52123717297638UL, 53665866335601UL, 55208537403431UL, 56751730677841UL, 58295446335601UL, 59839684553543UL,
        61384445508556UL, 62929729377592UL, 64475536337662UL, 66021866565835UL, 67568720239242UL, 69116097535075UL, 70663998630582UL, 72212423703076UL,
        73761372929925UL, 75310846488560UL, 76860844556473UL, 78411367311213UL, 79962414930392UL, 81513987591680UL, 83066085472808UL, 84618708751567UL,
        86171857605809UL, 87725532213445UL, 89279732752447UL, 90834459400847UL, 92389712336738UL, 93945491738271UL, 95501797783659UL, 97058630651177UL,
        98615990519156UL, 100173877565992UL, 101732291970139UL, 103291233910110UL, 104850703564482UL, 106410701111890UL, 107971226731030UL, 109532280600659UL,
        111093862899593UL, 112655973806710UL, 114218613500948UL, 115781782161306UL, 117345479966844UL, 118909707096680UL, 120474463729997UL, 122039750046034UL,
        123605566224094UL, 125171912443539UL, 126738788883793UL, 128306195724339UL, 129874133144723UL, 131442601324549UL, 133011600443485UL, 134581130681257UL,
        136151192217654UL, 137721785232524UL, 139292909905777UL, 140864566417384UL, 142436754947376UL, 144009475675845UL, 145582728782946UL, 147156514448892UL,
        148730832853960UL, 150305684178485UL, 151881068602866UL, 153456986307560UL, 155033437473087UL, 156610422280029UL, 158187940909026UL, 159765993540783UL,
        161344580356064UL, 162923701535693UL, 164503357260557UL, 166083547711605UL, 167664273069846UL, 169245533516349UL, 170827329232247UL, 172409660398732UL,
        173992527197059UL, 175575929808544UL, 177159868414563UL, 178744343196556UL, 180329354336021UL, 181914902014521UL, 183500986413678UL, 185087607715176UL,
        186674766100761UL, 188262461752241UL, 189850694851484UL, 191439465580420UL, 193028774121042UL, 194618620655404UL, 196209005365620UL, 197799928433867UL,
        199391390042383UL, 200983390373470UL, 202575929609489UL, 204169007932863UL, 205762625526079UL, 207356782571682UL, 208951479252283UL, 210546715750552UL,
        212142492249221UL, 213738808931086UL, 215335665979002UL, 216933063575887UL, 218531001904723UL, 220129481148550UL, 221728501490474UL, 223328063113659UL,
        224928166201335UL, 226528810936791UL, 228129997503380UL, 229731726084515UL, 231333996863674UL, 232936810024393UL, 234540165750274UL, 236144064224980UL,
        237748505632236UL, 239353490155827UL, 240959017979605UL, 242565089287479UL, 244171704263424UL, 245778863091477UL, 247386565955734UL, 248994813040358UL,
        250603604529570UL, 252212940607656UL, 253822821458965UL, 255433247267905UL, 257044218218950UL, 258655734496635UL, 260267796285556UL, 261880403770375UL,
        263493557135813UL, 265107256566655UL, 266721502247749UL, 268336294364006UL, 269951633100397UL, 271567518641958UL, 273183951173787UL, 274800930881045UL,
        276418457948955UL, 278036532562803UL, 279655154907937UL, 281274325169769UL, 282894043533774UL, 284514310185488UL, 286135125310511UL, 287756489094506UL,
        289378401723198UL, 291000863382376UL, 292623874257890UL, 294247434535656UL, 295871544401649UL, 297496204041911UL, 299121413642543UL, 300747173389713UL,
        302373483469649UL, 304000344068643UL, 305627755373050UL, 307255717569289UL, 308884230843841UL, 310513295383250UL, 312142911374124UL, 313773079003134UL,
        315403798457014UL, 317035069922560UL, 318666893586633UL, 320299269636158UL, 321932198258120UL, 323565679639570UL, 325199713967621UL, 326834301429451UL,
        328469442212300UL, 330105136503471UL, 331741384490331UL, 333378186360311UL, 335015542300905UL, 336653452499669UL, 338291917144226UL, 339930936422258UL,
        341570510521515UL, 343210639629807UL, 344851323935010UL, 346492563625062UL, 348134358887966UL, 349776709911787UL, 351419616884655UL, 353063079994763UL,
        354707099430368UL, 356351675379790UL, 357996808031415UL, 359642497573690UL, 361288744195128UL, 362935548084303UL, 364582909429857UL, 366230828420491UL,
        367879305244974UL, 369528340092136UL, 371177933150874UL, 372828084610145UL, 374478794658974UL, 376130063486447UL, 377781891281715UL, 379434278233993UL,
        381087224532561UL, 382740730366762UL, 384394795926002UL, 386049421399754UL, 387704606977554UL, 389360352849000UL, 391016659203756UL, 392673526231552UL,
        394330954122178UL, 395988943065492UL, 397647493251415UL, 399306604869932UL, 400966278111091UL, 402626513165008UL, 404287310221860UL, 405948669471889UL,
        407610591105403UL, 409273075312773UL, 410936122284434UL, 412599732210887UL, 414263905282697UL, 415928641690493UL, 417593941624968UL, 419259805276882UL,
        420926232837056UL, 422593224496379UL, 424260780445802UL, 425928900876342UL, 427597585979081UL, 429266835945164UL, 430936650965803UL, 432607031232273UL,
        434277976935914UL, 435949488268131UL, 437621565420395UL, 439294208584239UL, 440967417951263UL, 442641193713132UL, 444315536061575UL, 445990445188386UL,
        447665921285423UL, 449341964544612UL, 451018575157940UL, 452695753317463UL, 454373499215298UL, 456051813043629UL, 457730694994707UL, 459410145260845UL,
        461090164034421UL, 462770751507881UL, 464451907873735UL, 466133633324556UL, 467815928052984UL, 469498792251725UL, 471182226113549UL, 472866229831291UL,
        474550803597852UL, 476235947606199UL, 477921662049363UL, 479607947120440UL, 481294803012592UL, 482982229919048UL, 484670228033100UL, 486358797548107UL,
        488047938657492UL, 489737651554744UL, 491427936433419UL, 493118793487137UL, 494810222909583UL, 496502224894510UL, 498194799635733UL, 499887947327136UL,
        501581668162667UL, 503275962336340UL, 504970830042234UL, 506666271474495UL, 508362286827334UL, 510058876295027UL, 511756040071917UL, 513453778352412UL,
        515152091330986UL, 516850979202180UL, 518550442160599UL, 520250480400914UL, 521951094117864UL, 523652283506251UL, 525354048760945UL, 527056390076882UL,
        528759307649063UL, 530462801672555UL, 532166872342491UL, 533871519854072UL, 535576744402562UL, 537282546183294UL, 538988925391664UL, 540695882223138UL,
        542403416873245UL, 544111529537581UL, 545820220411808UL, 547529489691657UL, 549239337572920UL, 550949764251461UL, 552660769923205UL, 554372354784148UL,
        556084519030349UL, 557797262857934UL, 559510586463098UL, 561224490042099UL, 562938973791262UL, 564654037906981UL, 566369682585714UL, 568085908023987UL,
        569802714418390UL, 571520101965583UL, 573238070862290UL, 574956621305303UL, 576675753491480UL, 578395467617745UL, 580115763881091UL, 581836642478575UL,
        583558103607321UL, 585280147464522UL, 587002774247436UL, 588725984153388UL, 590449777379769UL, 592174154124039UL, 593899114583722UL, 595624658956411UL,
        597350787439766UL, 599077500231513UL, 600804797529444UL, 602532679531420UL, 604261146435367UL, 605990198439281UL, 607719835741221UL, 609450058539316UL,
        611180867031761UL, 612912261416819UL, 614644241892818UL, 616376808658156UL, 618109961911295UL, 619843701850767UL, 621578028675170UL, 623312942583169UL,
        625048443773496UL, 626784532444952UL, 628521208796404UL, 630258473026785UL, 631996325335098UL, 633734765920411UL, 635473794981862UL, 637213412718654UL,
        638953619330058UL, 640694415015414UL, 642435799974127UL, 644177774405672UL, 645920338509589UL, 647663492485488UL, 649407236533045UL, 651151570852003UL,
        652896495642175UL, 654642011103440UL, 656388117435745UL, 658134814839104UL, 659882103513599UL, 661629983659382UL, 663378455476668UL, 665127519165745UL,
        666877174926965UL, 668627422960750UL, 670378263467589UL, 672129696648037UL, 673881722702722UL, 675634341832334UL, 677387554237635UL, 679141360119453UL,
        680895759678685UL, 682650753116296UL, 684406340633317UL, 686162522430850UL, 687919298710064UL, 689676669672195UL, 691434635518548UL, 693193196450496UL,
        694952352669481UL, 696712104377013UL, 698472451774667UL, 700233395064092UL, 701994934447000UL, 703757070125175UL, 705519802300466UL, 707283131174794UL,
        709047056950145UL, 710811579828575UL, 712576700012209UL, 714342417703239UL, 716108733103926UL, 717875646416599UL, 719643157843658UL, 721411267587568UL,
        723179975850864UL, 724949282836150UL, 726719188746098UL, 728489693783450UL, 730260798151013UL, 732032502051668UL, 733804805688359UL, 735577709264104UL,
        737351212981985UL, 739125317045157UL, 740900021656840UL, 742675327020325UL, 744451233338972UL, 746227740816208UL, 748004849655532UL, 749782560060507UL,
        751560872234771UL, 753339786382025UL, 755119302706043UL, 756899421410667UL, 758680142699807UL, 760461466777443UL, 762243393847624UL, 764025924114467UL,
        765809057782160UL, 767592795054958UL, 769377136137187UL, 771162081233241UL, 772947630547584UL, 774733784284748UL, 776520542649335UL, 778307905846018UL,
        780095874079535UL, 781884447554697UL, 783673626476383UL, 785463411049542UL, 787253801479192UL, 789044797970419UL, 790836400728381UL, 792628609958304UL,
        794421425865483UL, 796214848655284UL, 798008878533141UL, 799803515704559UL, 801598760375110UL, 803394612750439UL, 805191073036259UL, 806988141438351UL,
        808785818162569UL, 810584103414835UL, 812382997401139UL, 814182500327543UL, 815982612400179UL, 817783333825247UL, 819584664809019UL, 821386605557833UL,
        823189156278102UL, 824992317176305UL, 826796088458992UL, 828600470332784UL, 830405463004370UL, 832211066680510UL, 834017281568035UL, 835824107873844UL,
        837631545804907UL, 839439595568265UL, 841248257371027UL, 843057531420374UL, 844867417923556UL, 846677917087894UL, 848489029120779UL, 850300754229671UL,
        852113092622101UL, 853926044505672UL, 855739610088054UL, 857553789576990UL, 859368583180292UL, 861183991105843UL, 863000013561595UL, 864816650755573UL,
        866633902895869UL, 868451770190649UL, 870270252848147UL, 872089351076668UL, 873909065084588UL, 875729395080353UL, 877550341272480UL, 879371903869557UL,
        881194083080241UL, 883016879113262UL, 884840292177418UL, 886664322481580UL, 888488970234688UL, 890314235645754UL, 892140118923860UL, 893966620278158UL,
        895793739917874UL, 897621478052300UL, 899449834890803UL, 901278810642820UL, 903108405517856UL, 904938619725491UL, 906769453475373UL, 908600906977223UL,
        910432980440831UL, 912265674076060UL, 914098988092842UL, 915932922701183UL, 917767478111156UL, 919602654532908UL, 921438452176658UL, 923274871252693UL,
        925111911971373UL, 926949574543129UL, 928787859178465UL, 930626766087952UL, 932466295482237UL, 934306447572034UL, 936147222568132UL, 937988620681390UL,
        939830642122737UL, 941673287103175UL, 943516555833777UL, 945360448525688UL, 947204965390123UL, 949050106638370UL, 950895872481788UL, 952742263131808UL,
        954589278799931UL, 956436919697731UL, 958285186036853UL, 960134078029015UL, 961983595886004UL, 963833739819682UL, 965684510041980UL, 967535906764901UL,
        969387930200523UL, 971240580560991UL, 973093858058524UL, 974947762905415UL, 976802295314025UL, 978657455496789UL, 980513243666214UL, 982369660034879UL,
        984226704815434UL, 986084378220601UL, 987942680463174UL, 989801611756022UL, 991661172312081UL, 993521362344363UL, 995382182065951UL, 997243631689998UL,
        999105711429734UL, 1000968421498455UL, 1002831762109535UL, 1004695733476417UL, 1006560335812616UL, 1008425569331721UL, 1010291434247393UL, 1012157930773364UL,
        1014025059123439UL, 1015892819511496UL, 1017761212151484UL, 1019630237257427UL, 1021499895043419UL, 1023370185723628UL, 1025241109512292UL, 1027112666623725UL,
        1028984857272311UL, 1030857681672508UL, 1032731140038845UL, 1034605232585926UL, 1036479959528426UL, 1038355321081092UL, 1040231317458745UL, 1042107948876279UL,
        1043985215548660UL, 1045863117690927UL, 1047741655518191UL, 1049620829245636UL, 1051500639088521UL, 1053381085262175UL, 1055262167982001UL, 1057143887463476UL,
        1059026243922149UL, 1060909237573640UL, 1062792868633646UL, 1064677137317934UL, 1066562043842344UL, 1068447588422792UL, 1070333771275264UL, 1072220592615821UL,
        1074108052660595UL, 1075996151625794UL, 1077884889727696UL, 1079774267182656UL, 1081664284207098UL, 1083554941017523UL, 1085446237830503UL, 1087338174862684UL,
        1089230752330786UL, 1091123970451601UL, 1093017829441996UL, 1094912329518909UL, 1096807470899355UL, 1098703253800418UL, 1100599678439260UL, 1102496745033113UL,
        1104394453799285UL, 1106292804955156UL, 1108191798718179UL, 1110091435305884UL, 1111991714935871UL, 1113892637825814UL, 1115794204193464UL, 1117696414256642UL,
        1119599268233244UL, 1121502766341240UL, 1123406908798674UL, 1125311695823663UL, 1127217127634399UL, 1129123204449147UL, 1131029926486245UL, 1132937293964107UL,
        1134845307101220UL, 1136753966116145UL, 1138663271227516UL, 1140573222654042UL, 1142483820614506UL, 1144395065327765UL, 1146306957012750UL, 1148219495888467UL,
        1150132682173994UL, 1152046516088485UL, 1153960997851167UL, 1155876127681343UL, 1157791905798389UL, 1159708332421754UL, 1161625407770963UL, 1163543132065616UL,
        1165461505525386UL, 1167380528370019UL, 1169300200819339UL, 1171220523093241UL, 1173141495411697UL, 1175063117994752UL, 1176985391062525UL, 1178908314835211UL,
        1180831889533079UL, 1182756115376472UL, 1184680992585808UL, 1186606521381580UL, 1188532701984355UL, 1190459534614775UL, 1192387019493556UL, 1194315156841491UL,
        1196243946879444UL, 1198173389828357UL, 1200103485909246UL, 1202034235343200UL, 1203965638351386UL, 1205897695155042UL, 1207830405975485UL, 1209763771034105UL,
        1211697790552365UL, 1213632464751806UL, 1215567793854043UL, 1217503778080766UL, 1219440417653740UL, 1221377712794804UL, 1223315663725874UL, 1225254270668939UL,
        1227193533846066UL, 1229133453479394UL, 1231074029791140UL, 1233015263003595UL, 1234957153339124UL, 1236899701020169UL, 1238842906269246UL, 1240786769308949UL,
        1242731290361943UL, 1244676469650973UL, 1246622307398856UL, 1248568803828486UL, 1250515959162832UL, 1252463773624938UL, 1254412247437925UL, 1256361380824988UL,
        1258311174009399UL, 1260261627214503UL, 1262212740663723UL, 1264164514580558UL, 1266116949188581UL, 1268070044711441UL, 1270023801372863UL, 1271978219396648UL,
        1273933299006672UL, 1275889040426888UL, 1277845443881324UL, 1279802509594083UL, 1281760237789345UL, 1283718628691367UL, 1285677682524479UL, 1287637399513090UL,
        1289597779881682UL, 1291558823854815UL, 1293520531657125UL, 1295482903513323UL, 1297445939648196UL, 1299409640286609UL, 1301374005653501UL, 1303339035973888UL,
        1305304731472862UL, 1307271092375592UL, 1309238118907322UL, 1311205811293373UL, 1313174169759142UL, 1315143194530101UL, 1317112885831802UL, 1319083243889870UL,
        1321054268930007UL, 1323025961177992UL, 1324998320859680UL, 1326971348201004UL, 1328945043427971UL, 1330919406766665UL, 1332894438443249UL, 1334870138683959UL,
        1336846507715111UL, 1338823545763095UL, 1340801253054378UL, 1342779629815506UL, 1344758676273098UL, 1346738392653853UL, 1348718779184545UL, 1350699836092024UL,
        1352681563603220UL, 1354663961945137UL, 1356647031344856UL, 1358630772029536UL, 1360615184226411UL, 1362600268162796UL, 1364586024066078UL, 1366572452163724UL,
        1368559552683277UL, 1370547325852358UL, 1372535771898663UL, 1374524891049967UL, 1376514683534122UL, 1378505149579056UL, 1380496289412774UL, 1382488103263361UL,
        1384480591358975UL, 1386473753927854UL, 1388467591198313UL, 1390462103398744UL, 1392457290757616UL, 1394453153503476UL, 1396449691864947UL, 1398446906070731UL,
        1400444796349607UL, 1402443362930430UL, 1404442606042135UL, 1406442525913732UL, 1408443122774311UL, 1410444396853037UL, 1412446348379154UL, 1414448977581984UL,
        1416452284690926UL, 1418456269935456UL, 1420460933545129UL, 1422466275749577UL, 1424472296778509UL, 1426478996861713UL, 1428486376229055UL, 1430494435110478UL,
        1432503173736002UL, 1434512592335726UL, 1436522691139828UL, 1438533470378562UL, 1440544930282260UL, 1442557071081333UL, 1444569893006270UL, 1446583396287637UL,
        1448597581156079UL, 1450612447842318UL, 1452627996577156UL, 1454644227591471UL, 1456661141116221UL, 1458678737382440UL, 1460697016621242UL, 1462715979063820UL,
        1464735624941442UL, 1466755954485457UL, 1468776967927292UL, 1470798665498452UL, 1472821047430520UL, 1474844113955157UL, 1476867865304104UL, 1478892301709179UL,
        1480917423402279UL, 1482943230615380UL, 1484969723580536UL, 1486996902529880UL, 1489024767695622UL, 1491053319310052UL, 1493082557605539UL, 1495112482814530UL,
        1497143095169551UL, 1499174394903205UL, 1501206382248177UL, 1503239057437228UL, 1505272420703199UL, 1507306472279010UL, 1509341212397659UL, 1511376641292222UL,
        1513412759195858UL, 1515449566341800UL, 1517487062963362UL, 1519525249293939UL, 1521564125567001UL, 1523603692016100UL, 1525643948874866UL, 1527684896377008UL,
        1529726534756314UL, 1531768864246653UL, 1533811885081971UL, 1535855597496293UL, 1537900001723724UL, 1539945097998450UL, 1541990886554733UL, 1544037367626917UL,
        1546084541449423UL, 1548132408256753UL, 1550180968283488UL, 1552230221764289UL, 1554280168933895UL, 1556330810027126UL, 1558382145278879UL, 1560434174924135UL,
        1562486899197949UL, 1564540318335460UL, 1566594432571885UL, 1568649242142520UL, 1570704747282741UL, 1572760948228005UL, 1574817845213846UL, 1576875438475881UL,
        1578933728249804UL, 1580992714771390UL, 1583052398276494UL, 1585112779001051UL, 1587173857181074UL, 1589235633052659UL, 1591298106851979UL, 1593361278815288UL,
        1595425149178921UL, 1597489718179292UL, 1599554986052895UL, 1601620953036304UL, 1603687619366174UL, 1605754985279238UL, 1607823051012312UL, 1609891816802290UL,
        1611961282886147UL, 1614031449500938UL, 1616102316883798UL, 1618173885271944UL, 1620246154902671UL, 1622319126013355UL, 1624392798841453UL, 1626467173624502UL,
        1628542250600119UL, 1630618030006003UL, 1632694512079930UL, 1634771697059762UL, 1636849585183436UL, 1638928176688972UL, 1641007471814471UL, 1643087470798114UL,
        1645168173878163UL, 1647249581292959UL, 1649331693280926UL, 1651414510080568UL, 1653498031930469UL, 1655582259069293UL, 1657667191735788UL, 1659752830168780UL,
        1661839174607176UL, 1663926225289966UL, 1666013982456218UL, 1668102446345083UL, 1670191617195791UL, 1672281495247657UL, 1674372080740072UL, 1676463373912510UL,
        1678555375004529UL, 1680648084255763UL, 1682741501905931UL, 1684835628194831UL, 1686930463362342UL, 1689026007648428UL, 1691122261293129UL, 1693219224536569UL,
        1695316897618953UL, 1697415280780567UL, 1699514374261779UL, 1701614178303038UL, 1703714693144874UL, 1705815919027899UL, 1707917856192805UL, 1710020504880369UL,
        1712123865331444UL, 1714227937786971UL, 1716332722487967UL, 1718438219675533UL, 1720544429590852UL, 1722651352475188UL, 1724758988569887UL, 1726867338116376UL,
        1728976401356165UL, 1731086178530843UL, 1733196669882085UL, 1735307875651644UL, 1737419796081357UL, 1739532431413143UL, 1741645781889000UL, 1743759847751012UL,
        1745874629241341UL, 1747990126602235UL, 1750106340076021UL, 1752223269905109UL, 1754340916331992UL, 1756459279599242UL, 1758578359949517UL, 1760698157625555UL,
        1762818672870176UL, 1764939905926283UL, 1767061857036861UL, 1769184526444978UL, 1771307914393783UL, 1773432021126507UL, 1775556846886465UL, 1777682391917053UL,
        1779808656461751UL, 1781935640764119UL, 1784063345067801UL, 1786191769616524UL, 1788320914654096UL, 1790450780424408UL, 1792581367171435UL, 1794712675139233UL,
        1796844704571941UL, 1798977455713780UL, 1801110928809055UL, 1803245124102153UL, 1805380041837543UL, 1807515682259779UL, 1809652045613496UL, 1811789132143411UL,
        1813926942094326UL, 1816065475711124UL, 1818204733238773UL, 1820344714922321UL, 1822485421006902UL, 1824626851737731UL, 1826769007360106UL, 1828911888119410UL,
        1831055494261107UL, 1833199826030745UL, 1835344883673954UL, 1837490667436449UL, 1839637177564026UL, 1841784414302568UL, 1843932377898036UL, 1846081068596478UL,
        1848230486644024UL, 1850380632286888UL, 1852531505771367UL, 1854683107343840UL, 1856835437250772UL, 1858988495738709UL, 1861142283054282UL, 1863296799444206UL,
        1865452045155277UL, 1867608020434376UL, 1869764725528469UL, 1871922160684604UL, 1874080326149912UL, 1876239222171609UL, 1878398848996995UL, 1880559206873452UL,
        1882720296048446UL, 1884882116769529UL, 1887044669284334UL, 1889207953840580UL, 1891371970686069UL, 1893536720068686UL, 1895702202236400UL, 1897868417437267UL,
        1900035365919423UL, 1902203047931090UL, 1904371463720573UL, 1906540613536263UL, 1908710497626633UL, 1910881116240241UL, 1913052469625729UL, 1915224558031823UL,
        1917397381707333UL, 1919570940901155UL, 1921745235862267UL, 1923920266839733UL, 1926096034082698UL, 1928272537840397UL, 1930449778362144UL, 1932627755897340UL,
        1934806470695471UL, 1936985923006105UL, 1939166113078897UL, 1941347041163585UL, 1943528707509992UL, 1945711112368025UL, 1947894255987677UL, 1950078138619024UL,
        1952262760512229UL, 1954448121917536UL, 1956634223085277UL, 1958821064265867UL, 1961008645709807UL, 1963196967667681UL, 1965386030390160UL, 1967575834127998UL,
        1969766379132036UL, 1971957665653197UL, 1974149693942491UL, 1976342464251013UL, 1978535976829942UL, 1980730231930542UL, 1982925229804164UL, 1985120970702242UL,
        1987317454876295UL, 1989514682577929UL, 1991712654058833UL, 1993911369570783UL, 1996110829365640UL, 1998311033695348UL, 2000511982811940UL, 2002713676967531UL,
        2004916116414324UL, 2007119301404605UL, 2009323232190746UL, 2011527909025206UL, 2013733332160529UL, 2015939501849342UL, 2018146418344360UL, 2020354081898384UL,
        2022562492764298UL, 2024771651195074UL, 2026981557443768UL, 2029192211763523UL, 2031403614407567UL, 2033615765629214UL, 2035828665681863UL, 2038042314819000UL,
        2040256713294196UL, 2042471861361107UL, 2044687759273477UL, 2046904407285134UL, 2049121805649993UL, 2051339954622054UL, 2053558854455405UL, 2055778505404217UL,
        2057998907722749UL, 2060220061665347UL, 2062441967486440UL, 2064664625440546UL, 2066888035782268UL, 2069112198766295UL, 2071337114647403UL, 2073562783680453UL,
        2075789206120393UL, 2078016382222258UL, 2080244312241167UL, 2082472996432330UL, 2084702435051037UL, 2086932628352671UL, 2089163576592695UL, 2091395280026665UL,
        2093627738910217UL, 2095860953499080UL, 2098094924049063UL, 2100329650816068UL, 2102565134056079UL, 2104801374025168UL, 2107038370979494UL, 2109276125175303UL,
        2111514636868927UL, 2113753906316786UL, 2115993933775385UL, 2118234719501317UL, 2120476263751261UL, 2122718566781985UL, 2124961628850341UL, 2127205450213269UL,
        2129450031127798UL, 2131695371851042UL, 2133941472640201UL, 2136188333752564UL, 2138435955445507UL, 2140684337976493UL, 2142933481603071UL, 2145183386582878UL,
        2147434053173639UL, 2149685481633164UL, 2151937672219353UL, 2154190625190192UL, 2156444340803754UL, 2158698819318199UL, 2160954060991776UL, 2163210066082820UL,
        2165466834849755UL, 2167724367551090UL, 2169982664445423UL, 2172241725791441UL, 2174501551847916UL, 2176762142873709UL, 2179023499127767UL, 2181285620869128UL,
        2183548508356914UL, 2185812161850338UL, 2188076581608697UL, 2190341767891379UL, 2192607720957859UL, 2194874441067698UL, 2197141928480548UL, 2199410183456147UL,
        2201679206254320UL, 2203948997134983UL, 2206219556358136UL, 2208490884183870UL, 2210762980872364UL, 2213035846683883UL, 2215309481878782UL, 2217583886717504UL,
        2219859061460578UL, 2222135006368624UL, 2224411721702349UL, 2226689207722548UL, 2228967464690105UL, 2231246492865992UL, 2233526292511268UL, 2235806863887083UL,
        2238088207254673UL, 2240370322875364UL, 2242653211010570UL, 2244936871921793UL, 2247221305870623UL, 2249506513118742UL, 2251792493927916UL, 2254079248560002UL,
        2256366777276946UL, 2258655080340781UL, 2260944158013630UL, 2263234010557705UL, 2265524638235305UL, 2267816041308820UL, 2270108220040727UL, 2272401174693593UL,
        2274694905530073UL, 2276989412812913UL, 2279284696804944UL, 2281580757769090UL, 2283877595968362UL, 2286175211665860UL, 2288473605124774UL, 2290772776608381UL,
        2293072726380051UL, 2295373454703238UL, 2297674961841491UL, 2299977248058442UL, 2302280313617818UL, 2304584158783432UL, 2306888783819186UL, 2309194188989073UL,
        2311500374557175UL, 2313807340787663UL, 2316115087944797UL, 2318423616292928UL, 2320732926096493UL, 2323043017620024UL, 2325353891128138UL, 2327665546885543UL,
        2329977985157037UL, 2332291206207507UL, 2334605210301930UL, 2336919997705374UL, 2339235568682993UL, 2341551923500035UL, 2343869062421836UL, 2346186985713820UL,
        2348505693641505UL, 2350825186470495UL, 2353145464466485UL, 2355466527895262UL, 2357788377022700UL, 2360111012114765UL, 2362434433437512UL, 2364758641257087UL,
        2367083635839725UL, 2369409417451751UL, 2371735986359581UL, 2374063342829723UL, 2376391487128770UL, 2378720419523411UL, 2381050140280422UL, 2383380649666669UL,
        2385711947949110UL, 2388044035394793UL, 2390376912270856UL, 2392710578844528UL, 2395045035383127UL, 2397380282154063UL, 2399716319424836UL, 2402053147463036UL,
        2404390766536345UL, 2406729176912535UL, 2409068378859467UL, 2411408372645096UL, 2413749158537463UL, 2416090736804705UL, 2418433107715047UL, 2420776271536804UL,
        2423120228538383UL, 2425464978988283UL, 2427810523155092UL, 2430156861307488UL, 2432503993714244UL, 2434851920644220UL, 2437200642366369UL, 2439550159149735UL,
        2441900471263451UL, 2444251578976745UL, 2446603482558932UL, 2448956182279421UL, 2451309678407710UL, 2453663971213391UL, 2456019060966146UL, 2458374947935746UL,
        2460731632392056UL, 2463089114605033UL, 2465447394844723UL, 2467806473381265UL, 2470166350484888UL, 2472527026425914UL, 2474888501474756UL, 2477250775901918UL,
        2479613849977996UL, 2481977723973678UL, 2484342398159743UL, 2486707872807062UL, 2489074148186598UL, 2491441224569405UL, 2493809102226628UL, 2496177781429506UL,
        2498547262449369UL, 2500917545557637UL, 2503288631025825UL, 2505660519125537UL, 2508033210128471UL, 2510406704306416UL, 2512781001931254UL, 2515156103274957UL,
        2517532008609590UL, 2519908718207312UL, 2522286232340371UL, 2524664551281110UL, 2527043675301963UL, 2529423604675454UL, 2531804339674204UL, 2534185880570921UL,
        2536568227638410UL, 2538951381149566UL, 2541335341377376UL, 2543720108594920UL, 2546105683075372UL, 2548492065091995UL, 2550879254918147UL, 2553267252827279UL,
        2555656059092934UL, 2558045673988745UL, 2560436097788441UL, 2562827330765843UL, 2565219373194864UL, 2567612225349509UL, 2570005887503877UL, 2572400359932160UL,
        2574795642908642UL, 2577191736707700UL, 2579588641603804UL, 2581986357871516UL, 2584384885785494UL, 2586784225620484UL, 2589184377651331UL, 2591585342152967UL,
        2593987119400421UL, 2596389709668814UL, 2598793113233361UL, 2601197330369367UL, 2603602361352235UL, 2606008206457457UL, 2608414865960621UL, 2610822340137407UL,
        2613230629263589UL, 2615639733615033UL, 2618049653467699UL, 2620460389097642UL, 2622871940781009UL, 2625284308794039UL, 2627697493413069UL, 2630111494914524UL,
        2632526313574927UL, 2634941949670892UL, 2637358403479128UL, 2639775675276437UL, 2642193765339715UL, 2644612673945952UL, 2647032401372230UL, 2649452947895727UL,
        2651874313793715UL, 2654296499343558UL, 2656719504822714UL, 2659143330508736UL, 2661567976679272UL, 2663993443612061UL, 2666419731584939UL, 2668846840875833UL,
        2671274771762768UL, 2673703524523858UL, 2676133099437317UL, 2678563496781448UL, 2680994716834651UL, 2683426759875421UL, 2685859626182344UL, 2688293316034103UL,
        2690727829709474UL, 2693163167487329UL, 2695599329646633UL, 2698036316466445UL, 2700474128225921UL, 2702912765204307UL, 2705352227680949UL, 2707792515935283UL,
        2710233630246842UL, 2712675570895253UL, 2715118338160237UL, 2717561932321612UL, 2720006353659288UL, 2722451602453270UL, 2724897678983661UL, 2727344583530654UL,
        2729792316374541UL, 2732240877795706UL, 2734690268074629UL, 2737140487491886UL, 2739591536328147UL, 2742043414864177UL, 2744496123380835UL, 2746949662159076UL,
        2749404031479952UL, 2751859231624607UL, 2754315262874282UL, 2756772125510313UL, 2759229819814130UL, 2761688346067261UL, 2764147704551325UL, 2766607895548041UL,
        2769068919339221UL, 2771530776206771UL, 2773993466432696UL, 2776456990299094UL, 2778921348088158UL, 2781386540082179UL, 2783852566563541UL, 2786319427814725UL,
        2788787124118307UL, 2791255655756960UL, 2793725023013451UL, 2796195226170643UL, 2798666265511495UL, 2801138141319063UL, 2803610853876497UL, 2806084403467044UL,
        2808558790374046UL, 2811034014880941UL, 2813510077271264UL, 2815986977828645UL, 2818464716836811UL, 2820943294579583UL, 2823422711340880UL, 2825902967404717UL,
        2828384063055205UL, 2830865998576549UL, 2833348774253054UL, 2835832390369118UL, 2838316847209237UL, 2840802145058004UL, 2843288284200105UL, 2845775264920326UL,
        2848263087503547UL, 2850751752234747UL, 2853241259398999UL, 2855731609281473UL, 2858222802167436UL, 2860714838342252UL, 2863207718091380UL, 2865701441700378UL,
        2868196009454899UL, 2870691421640693UL, 2873187678543606UL, 2875684780449583UL, 2878182727644663UL, 2880681520414984UL, 2883181159046780UL, 2885681643826381UL,
        2888182975040216UL, 2890685152974809UL, 2893188177916782UL, 2895692050152854UL, 2898196769969841UL, 2900702337654655UL, 2903208753494308UL, 2905716017775905UL,
        2908224130786653UL, 2910733092813851UL, 2913242904144899UL, 2915753565067294UL, 2918265075868628UL, 2920777436836593UL, 2923290648258977UL, 2925804710423666UL,
        2928319623618642UL, 2930835388131987UL, 2933352004251878UL, 2935869472266591UL, 2938387792464499UL, 2940906965134074UL, 2943426990563883UL, 2945947869042593UL,
        2948469600858968UL, 2950992186301870UL, 2953515625660258UL, 2956039919223189UL, 2958565067279818UL, 2961091070119399UL, 2963617928031282UL, 2966145641304916UL,
        2968674210229849UL, 2971203635095724UL, 2973733916192285UL, 2976265053809372UL, 2978797048236926UL, 2981329899764982UL, 2983863608683677UL, 2986398175283244UL,
        2988933599854015UL, 2991469882686421UL, 2994007024070989UL, 2996545024298346UL, 2999083883659218UL, 3001623602444428UL, 3004164180944899UL, 3006705619451651UL,
        3009247918255802UL, 3011791077648571UL, 3014335097921274UL, 3016879979365325UL, 3019425722272238UL, 3021972326933626UL, 3024519793641198UL, 3027068122686764UL,
        3029617314362234UL, 3032167368959613UL, 3034718286771008UL, 3037270068088625UL, 3039822713204766UL, 3042376222411834UL, 3044930596002332UL, 3047485834268859UL,
        3050041937504116UL, 3052598906000902UL, 3055156740052115UL, 3057715439950751UL, 3060275005989907UL, 3062835438462779UL, 3065396737662662UL, 3067958903882949UL,
        3070521937417133UL, 3073085838558809UL, 3075650607601667UL, 3078216244839499UL, 3080782750566197UL, 3083350125075750UL, 3085918368662249UL, 3088487481619884UL,
        3091057464242943UL, 3093628316825815UL, 3096200039662988UL, 3098772633049051UL, 3101346097278692UL, 3103920432646698UL, 3106495639447956UL, 3109071717977453UL,
        3111648668530278UL, 3114226491401615UL, 3116805186886753UL, 3119384755281078UL, 3121965196880077UL, 3124546511979337UL, 3127128700874545UL, 3129711763861487UL,
        3132295701236050UL, 3134880513294223UL, 3137466200332092UL, 3140052762645845UL, 3142640200531770UL, 3145228514286255UL, 3147817704205789UL, 3150407770586960UL,
        3152998713726459UL, 3155590533921074UL, 3158183231467697UL, 3160776806663317UL, 3163371259805026UL, 3165966591190015UL, 3168562801115578UL, 3171159889879108UL,
        3173757857778097UL, 3176356705110141UL, 3178956432172934UL, 3181557039264272UL, 3184158526682054UL, 3186760894724274UL, 3189364143689034UL, 3191968273874531UL,
        3194573285579066UL, 3197179179101040UL, 3199785954738956UL, 3202393612791417UL, 3205002153557127UL, 3207611577334892UL, 3210221884423619UL, 3212833075122315UL,
        3215445149730090UL, 3218058108546154UL, 3220671951869819UL, 3223286680000497UL, 3225902293237702UL, 3228518791881052UL, 3231136176230262UL, 3233754446585151UL,
        3236373603245639UL, 3238993646511748UL, 3241614576683601UL, 3244236394061423UL, 3246859098945540UL, 3249482691636379UL, 3252107172434472UL, 3254732541640449UL,
        3257358799555044UL, 3259985946479091UL, 3262613982713527UL, 3265242908559391UL, 3267872724317824UL, 3270503430290069UL, 3273135026777469UL, 3275767514081472UL,
        3278400892503626UL, 3281035162345581UL, 3283670323909091UL, 3286306377496010UL, 3288943323408295UL, 3291581161948007UL, 3294219893417306UL, 3296859518118456UL,
        3299500036353823UL, 3302141448425876UL, 3304783754637186UL, 3307426955290427UL, 3310071050688373UL, 3312716041133904UL, 3315361926929999UL, 3318008708379744UL,
        3320656385786322UL, 3323304959453024UL, 3325954429683240UL, 3328604796780464UL, 3331256061048293UL, 3333908222790427UL, 3336561282310667UL, 3339215239912919UL,
        3341870095901191UL, 3344525850579594UL, 3347182504252341UL, 3349840057223750UL, 3352498509798240UL, 3355157862280334UL, 3357818114974658UL, 3360479268185942UL,
        3363141322219017UL, 3365804277378818UL, 3368468133970386UL, 3371132892298860UL, 3373798552669488UL, 3376465115387616UL, 3379132580758698UL, 3381800949088288UL,
        3384470220682045UL, 3387140395845731UL, 3389811474885212UL, 3392483458106458UL, 3395156345815540UL, 3397830138318636UL, 3400504835922026UL, 3403180438932093UL,
        3405856947655324UL, 3408534362398311UL, 3411212683467750UL, 3413891911170437UL, 3416572045813278UL, 3419253087703277UL, 3421935037147545UL, 3424617894453297UL,
        3427301659927852UL, 3429986333878631UL, 3432671916613161UL, 3435358408439073UL, 3438045809664101UL, 3440734120596085UL, 3443423341542968UL, 3446113472812796UL,
        3448804514713722UL, 3451496467554002UL, 3454189331641996UL, 3456883107286168UL, 3459577794795088UL, 3462273394477429UL, 3464969906641969UL, 3467667331597591UL,
        3470365669653282UL, 3473064921118134UL, 3475765086301343UL, 3478466165512210UL, 3481168159060141UL, 3483871067254646UL, 3486574890405341UL, 3489279628821945UL,
        3491985282814283UL, 3494691852692286UL, 3497399338765988UL, 3500107741345528UL, 3502817060741151UL, 3505527297263207UL, 3508238451222150UL, 3510950522928540UL,
        3513663512693043UL, 3516377420826427UL, 3519092247639569UL, 3521807993443449UL, 3524524658549153UL, 3527242243267871UL, 3529960747910900UL, 3532680172789643UL,
        3535400518215605UL, 3538121784500400UL, 3540843971955746UL, 3543567080893467UL, 3546291111625491UL, 3549016064463854UL, 3551741939720696UL, 3554468737708263UL,
        3557196458738907UL, 3559925103125085UL, 3562654671179361UL, 3565385163214403UL, 3568116579542987UL, 3570848920477994UL, 3573582186332409UL, 3576316377419327UL,
        3579051494051945UL, 3581787536543568UL, 3584524505207607UL, 3587262400357579UL, 3590001222307107UL, 3592740971369919UL, 3595481647859851UL, 3598223252090845UL,
        3600965784376949UL, 3603709245032316UL, 3606453634371207UL, 3609198952707989UL, 3611945200357135UL, 3614692377633225UL, 3617440484850946UL, 3620189522325089UL,
        3622939490370554UL, 3625690389302347UL, 3628442219435581UL, 3631194981085474UL, 3633948674567353UL, 3636703300196650UL, 3639458858288905UL, 3642215349159764UL,
        3644972773124980UL, 3647731130500412UL, 3650490421602028UL, 3653250646745902UL, 3656011806248215UL, 3658773900425253UL, 3661536929593413UL, 3664300894069196UL,
        3667065794169212UL, 3669831630210176UL, 3672598402508912UL, 3675366111382351UL, 3678134757147532UL, 3680904340121599UL, 3683674860621806UL, 3686446318965511UL,
        3689218715470184UL, 3691992050453399UL, 3694766324232839UL, 3697541537126293UL, 3700317689451660UL, 3703094781526944UL, 3705872813670258UL, 3708651786199824UL,
        3711431699433970UL, 3714212553691130UL, 3716994349289850UL, 3719777086548782UL, 3722560765786684UL, 3725345387322424UL, 3728130951474977UL, 3730917458563428UL,
        3733704908906966UL, 3736493302824893UL, 3739282640636615UL, 3742072922661647UL, 3744864149219615UL, 3747656320630249UL, 3750449437213390UL, 3753243499288986UL,
        3756038507177095UL, 3758834461197881UL, 3761631361671619UL, 3764429208918689UL, 3767228003259582UL, 3770027745014898UL, 3772828434505343UL, 3775630072051734UL,
        3778432657974995UL, 3781236192596159UL, 3784040676236369UL, 3786846109216874UL, 3789652491859035UL, 3792459824484319UL, 3795268107414303UL, 3798077340970673UL,
        3800887525475224UL, 3803698661249859UL, 3806510748616591UL, 3809323787897541UL, 3812137779414941UL, 3814952723491129UL, 3817768620448555UL, 3820585470609777UL,
        3823403274297461UL, 3826222031834385UL, 3829041743543433UL, 3831862409747602UL, 3834684030769994UL, 3837506606933824UL, 3840330138562414UL, 3843154625979198UL,
        3845980069507717UL, 3848806469471623UL, 3851633826194677UL, 3854462140000750UL, 3857291411213821UL, 3860121640157981UL, 3862952827157430UL, 3865784972536477UL,
        3868618076619541UL, 3871452139731151UL, 3874287162195946UL, 3877123144338675UL, 3879960086484196UL, 3882797988957479UL, 3885636852083602UL, 3888476676187753UL,
        3891317461595232UL, 3894159208631448UL, 3897001917621918UL, 3899845588892274UL, 3902690222768253UL, 3905535819575707UL, 3908382379640594UL, 3911229903288986UL,
        3914078390847064UL, 3916927842641117UL, 3919778258997549UL, 3922629640242870UL, 3925481986703705UL, 3928335298706785UL, 3931189576578956UL, 3934044820647171UL,
        3936901031238495UL, 3939758208680104UL, 3942616353299286UL, 3945475465423436UL, 3948335545380065UL, 3951196593496790UL, 3954058610101341UL, 3956921595521560UL,
        3959785550085399UL, 3962650474120920UL, 3965516367956297UL, 3968383231919816UL, 3971251066339872UL, 3974119871544973UL, 3976989647863738UL, 3979860395624896UL,
        3982732115157289UL, 3985604806789868UL, 3988478470851697UL, 3991353107671953UL, 3994228717579920UL, 3997105300904998UL, 3999982857976696UL, 4002861389124634UL,
        4005740894678546UL, 4008621374968275UL, 4011502830323778UL, 4014385261075123UL, 4017268667552488UL, 4020153050086165UL, 4023038409006556UL, 4025924744644177UL,
        4028812057329654UL, 4031700347393726UL, 4034589615167243UL, 4037479860981167UL, 4040371085166574UL, 4043263288054650UL, 4046156469976693UL, 4049050631264115UL,
        4051945772248438UL, 4054841893261298UL, 4057738994634442UL, 4060637076699731UL, 4063536139789136UL, 4066436184234743UL, 4069337210368747UL, 4072239218523458UL,
        4075142209031299UL, 4078046182224804UL, 4080951138436619UL, 4083857077999505UL, 4086764001246334UL, 4089671908510090UL, 4092580800123871UL, 4095490676420888UL,
        4098401537734464UL, 4101313384398034UL, 4104226216745149UL, 4107140035109469UL, 4110054839824769UL, 4112970631224938UL, 4115887409643975UL, 4118805175415996UL,
        4121723928875226UL, 4124643670356005UL, 4127564400192788UL, 4130486118720140UL, 4133408826272741UL, 4136332523185385UL, 4139257209792977UL, 4142182886430537UL,
        4145109553433198UL, 4148037211136208UL, 4150965859874925UL, 4153895499984824UL, 4156826131801492UL, 4159757755660629UL, 4162690371898050UL, 4165623980849682UL,
        4168558582851569UL, 4171494178239864UL, 4174430767350837UL, 4177368350520872UL, 4180306928086466UL, 4183246500384229UL, 4186187067750886UL, 4189128630523276UL,
        4192071189038352UL, 4195014743633181UL, 4197959294644944UL, 4200904842410936UL, 4203851387268566UL, 4206798929555358UL, 4209747469608950UL, 4212697007767094UL,
        4215647544367655UL, 4218599079748616UL, 4221551614248071UL, 4224505148204230UL, 4227459681955417UL, 4230415215840071UL, 4233371750196745UL, 4236329285364106UL,
        4239287821680938UL, 4242247359486137UL, 4245207899118715UL, 4248169440917799UL, 4251131985222631UL, 4254095532372566UL, 4257060082707076UL, 4260025636565747UL,
        4262992194288279UL, 4265959756214490UL, 4268928322684309UL, 4271897894037783UL, 4274868470615074UL, 4277840052756456UL, 4280812640802323UL, 4283786235093181UL,
        4286760835969652UL, 4289736443772473UL, 4292713058842497UL, 4295690681520691UL, 4298669312148140UL, 4301648951066043UL, 4304629598615713UL, 4307611255138581UL,
        4310593920976192UL, 4313577596470208UL, 4316562281962405UL, 4319547977794676UL, 4322534684309029UL, 4325522401847589UL, 4328511130752594UL, 4331500871366401UL,
        4334491624031480UL, 4337483389090421UL, 4340476166885926UL, 4343469957760815UL, 4346464762058022UL, 4349460580120601UL, 4352457412291718UL, 4355455258914657UL,
        4358454120332820UL, 4361453996889721UL, 4364454888928993UL, 4367456796794386UL, 4370459720829765UL, 4373463661379112UL, 4376468618786524UL, 4379474593396217UL,
        4382481585552521UL, 4385489595599884UL, 4388498623882871UL, 4391508670746163UL, 4394519736534557UL, 4397531821592967UL, 4400544926266425UL, 4403559050900078UL,
        4406574195839192UL, 4409590361429148UL, 4412607548015444UL, 4415625755943696UL, 4418644985559636UL, 4421665237209114UL, 4424686511238097UL, 4427708807992668UL,
        4430732127819028UL, 4433756471063495UL, 4436781838072504UL, 4439808229192608UL, 4442835644770477UL, 4445864085152898UL, 4448893550686775UL, 4451924041719131UL,
        4454955558597105UL, 4457988101667954UL, 4461021671279052UL, 4464056267777893UL, 4467091891512084UL, 4470128542829355UL, 4473166222077550UL, 4476204929604632UL,
        4479244665758681UL, 4482285430887897UL, 4485327225340595UL, 4488370049465210UL, 4491413903610294UL, 4494458788124517UL, 4497504703356668UL, 4500551649655653UL
    ];

    static MathUtils()
    {
        ExpMin = Vector256.Create(-708.396418532264);       // Math.Log(Math.Pow(2, -1022)) where -1022 is the minimum exponent of a double-precision floating-point number (IEEE 754)
        ExpMax = Vector256.Create(709.782712893384);        // Math.Log(double.MaxValue) = Math.Log(1.7976931348623157E+308)
        Alpha = Vector256.Create(2954.6394437406);          // 2048 / Math.Log(2)
        AlphaInv = Vector256.Create(0.000338450771757786);  // 1 / Alpha = Math.Log(2) / 2048
        // Optimized coefficients for the rational approximation of the exponential function
        C3 = Vector256.Create(3.0000000027955394);
        C2 = Vector256.Create(0.16666666685227835);
        C1 = Vector256.Create(1.0);
        Round = Vector256.Create(6755399441055744.0);       // 3UL << 51 as double
        Mask11 = Vector256.Create(2047UL);
        Adj = Vector256.Create(2095104UL);                  // (1UL << (TABLE_SIZE + 10)) - (1UL << TABLE_SIZE) where TABLE_SIZE = 11
    } // cctor ()

    /// <summary>
    /// Computes the exponential function for each element of the specified vector.
    /// </summary>
    /// <param name="v">The vector.</param>
    /// <returns>The exponential function for each element of the specified vector.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    unsafe public static Vector256<double> Exp(Vector256<double> v)
    {
        if (Avx.IsSupported && Avx2.IsSupported)
        {
            v = Avx.Min(v, ExpMax);
            v = Avx.Max(v, ExpMin);

            var d = Avx.Add(Avx.Multiply(v, Alpha), Round);
            var i = d.AsUInt64<double>();

            var u = Avx2.Add(i, Adj);
            u = Avx2.ShiftRightLogical(u, 11);
            u = Avx2.ShiftLeftLogical(u, 52);

            var t = Avx.Subtract(Avx.Multiply(Avx.Subtract(d, Round), AlphaInv), v);
            var y = Avx.Multiply(Avx.Subtract(C3, t), Avx.Multiply(t, t));
            y = Avx.Multiply(y, C2);
            y = Avx.Add(Avx.Subtract(y, t), C1);

            var adr = Avx2.And(i, Mask11).AsInt64();
            fixed (ulong* p = exp_table)
            {
                var iax = Avx2.GatherVector256(p, adr, 8);
                i = Avx2.Or(u, iax);
                return Avx.Multiply(i.AsDouble(), y);
            }
        }
        else
        {
            var arr = stackalloc double[4];
            arr[0] = FastExp(v.GetElement(0));
            arr[1] = FastExp(v.GetElement(1));
            arr[2] = FastExp(v.GetElement(2));
            arr[3] = FastExp(v.GetElement(3));
            return Avx.LoadVector256(arr);
        }
    } // unsafe public static Vector256<double> Exp (Vector256<double>)

    /// <summary>
    /// Computes the exponential function for the specified value.
    /// </summary>
    /// <param name="x">The value.</param>
    /// <returns>The exponential function for the specified value.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static double FastExp(double x)
    {
        if (x <= -708.396418532264) return 0;
        if (x >= 709.782712893384) return double.PositiveInfinity;

        var d = x * (2954.6394437406) + (6755399441055744);
        var i = BitConverter.DoubleToUInt64Bits(d);
        var iax = exp_table[i & 2047];
        var t = (d - (6755399441055744)) * 0.000338450771757786 - x;
        var u = ((i + 2095104) >> 11) << 52;
        var y = (3.0000000027955394 - t) * (t * t) * 0.16666666685227835 - t + 1;
        i = u | iax;
        d = BitConverter.UInt64BitsToDouble(i);

        return d * y;
    } // public static double FastExp (double)
} // file static class MathUtils

/// <summary>
/// Represents a vector of double values that can be processed using AVX instructions.
/// </summary>
/// <remarks>
/// It is recommended to use this class when the number of elements is greater than or equal to 4.
/// </remarks>
public sealed class AvxVector
{
    private readonly double[] _array;

    /// <summary>
    /// Gets a value indicating whether the <see cref="AvxVector"/> is supported on the current system.
    /// </summary>
    public static bool IsSupported => Avx.IsSupported && Avx2.IsSupported && Vector256.IsHardwareAccelerated && Vector256<double>.IsSupported;

    /// <summary>
    /// Gets the length of the vector.
    /// </summary>
    public int Length => this._array.Length;

    /// <summary>
    /// Gets a value indicating whether the current vector is readonly.
    /// </summary>
    public bool IsReadonly { get; } = false;

    /// <summary>
    /// Computes the sum of the elements in the vector.
    /// </summary>
    public double Sum
    {
        get
        {
            ref var begin = ref MemoryMarshal.GetArrayDataReference(this._array);
            ref var to = ref Unsafe.Add(ref begin, this._array.Length - Vector256<double>.Count);
            ref var current = ref begin;

            var sums = Vector256<double>.Zero;
            while (Unsafe.IsAddressLessThan(ref current, ref to))
            {
                var v = Vector256.LoadUnsafe(ref current);
                sums += v;
                current = ref Unsafe.Add(ref current, Vector256<double>.Count);
            }

            var sum = Vector256.Sum(sums);
            var offset = GetRemainingOffset(this);
            for (var i = offset; i < this._array.Length; i++)
                sum += this._array[i];

            return sum;
        }
    }

    /// <summary>
    /// Computes the square of the Euclidean norm of the vector.
    /// </summary>
    public double Norm2
    {
        get
        {
            ref var begin = ref MemoryMarshal.GetArrayDataReference(this._array);
            ref var to = ref Unsafe.Add(ref begin, this._array.Length - Vector256<double>.Count);
            ref var current = ref begin;

            var sums = Vector256<double>.Zero;
            while (Unsafe.IsAddressLessThan(ref current, ref to))
            {
                var v = Vector256.LoadUnsafe(ref current);
                sums += Vector256.Multiply(v, v);
                current = ref Unsafe.Add(ref current, Vector256<double>.Count);
            }

            var sum = Vector256.Sum(sums);
            var offset = GetRemainingOffset(this);
            for (var i = offset; i < this._array.Length; i++)
            {
                var v = this._array[i];
                sum += v * v;
            }

            return sum;
        }
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvxVector"/> class
    /// with the specified values.
    /// </summary>
    /// <param name="values">The values of the vector.</param>
    public AvxVector(double[] values) : this(values, false) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvxVector"/> class
    /// with the specified values and a value indicating whether the vector is readonly.
    /// </summary>
    /// <param name="values">The values of the vector.</param>
    /// <param name="isReadonly">A value indicating whether the vector is readonly.</param>
    public AvxVector(double[] values, bool isReadonly)
    {
        this.IsReadonly = isReadonly;
        this._array = values;
    } // ctor (double[], bool)

    /// <summary>
    /// Initializes a new instance of the <see cref="AvxVector"/> class
    /// with the specified count and value.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <param name="value">The value of the vector.</param>
    public AvxVector(int count, double value) : this(count, value, false) { }

    /// <summary>
    /// Initializes a new instance of the <see cref="AvxVector"/> class
    /// with the specified count, value, and a value indicating whether the vector is readonly.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <param name="value">The value of the vector.</param>
    /// <param name="isReadonly">The value indicating whether the vector is readonly.</param>
    /// <exception cref="ArgumentOutOfRangeException">The <paramref name="count"/> must be greater than or equal to zero.</exception>
    public AvxVector(int count, double value, bool isReadonly)
    {
        if (count < 0)
            throw new ArgumentOutOfRangeException(nameof(count), "The count must be greater than or equal to zero.");

        this.IsReadonly = isReadonly;
        this._array = new double[count];
        var span = this._array.AsSpan();
        span.Fill(value);
    } // ctor (int, double, bool)

    /// <summary>
    /// Initializes a new instance of the <see cref="AvxVector"/> class
    /// that has the specified number of elements.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <exception cref="ArgumentOutOfRangeException">The <paramref name="count"/> must be greater than or equal to zero.</exception>
    /// <remarks>All elements of the vector are initialized to zero.</remarks>
    public AvxVector(int count)
    {
        if (count < 0)
            throw new ArgumentOutOfRangeException(nameof(count), "The count must be greater than or equal to zero.");

        this._array = new double[count];
    } // ctor (int)

    /// <summary>
    /// Loads the specified values into the current vector.
    /// </summary>
    /// <param name="values">The values to load into the current vector.</param>
    /// <exception cref="InvalidOperationException">The current vector is readonly.</exception>
    /// <exception cref="ArgumentException">The length of the specified values does not match the length of the current vector.</exception>
    public void Load(double[] values)
    {
        if (this.IsReadonly)
            throw new InvalidOperationException("The current vector is readonly.");
        if (this._array.Length != values.Length)
            throw new ArgumentException("The length of the specified values does not match the length of the current vector.");
        values.CopyTo(this._array, 0);
    } // public void Load (double[])

    /// <summary>
    /// Loads the specified value into the current vector.
    /// </summary>
    /// <param name="value">The value to load into the current vector.</param>
    /// <exception cref="InvalidOperationException">The current vector is readonly.</exception>
    public void Load(double value)
    {
        if (this.IsReadonly)
            throw new InvalidOperationException("The current vector is readonly.");
        var span = this._array.AsSpan();
        span.Fill(value);
    } // public void Load (double)

    /// <summary>
    /// Creates a new instance of the <see cref="AvxVector"/> class with the specified values.
    /// </summary>
    /// <param name="values">The values of the vector.</param>
    /// <returns>A new <see cref="AvxVector"/> instance that contains the specified values.</returns>
    public static AvxVector Create(double[] values) => new(values, false);

    /// <summary>
    /// Creates a new instance of the <see cref="AvxVector"/> class with the specified count and value.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <param name="value">The value of the vector.</param>
    /// <returns>A new <see cref="AvxVector"/> instance that contains the specified values.</returns>
    public static AvxVector Create(int count, double value) => new(count, value, false);

    /// <summary>
    /// Creates a new instance of the <see cref="AvxVector"/> class with the specified count.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <returns>A new <see cref="AvxVector"/> instance that contains the specified values.</returns>
    public static AvxVector Create(int count) => new(count);

    /// <summary>
    /// Creates a new readonly instance of the <see cref="AvxVector"/> class with the specified values.
    /// </summary>
    /// <param name="values">The values of the vector.</param>
    /// <returns>A new readonly <see cref="AvxVector"/> instance that contains the specified values.</returns>
    public static AvxVector CreateReadonly(double[] values) => new(values, true);

    /// <summary>
    /// Creates a new readonly instance of the <see cref="AvxVector"/> class with the specified count and value.
    /// </summary>
    /// <param name="count">The number of elements in the vector.</param>
    /// <param name="value">The value of the vector.</param>
    /// <returns>A new readonly <see cref="AvxVector"/> instance that contains the specified values.</returns>
    public static AvxVector CreateReadonly(int count, double value) => new(count, value, true);

    /// <summary>
    /// Adds the specified vectors and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The left vector.</param>
    /// <param name="right">The right vector.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Add(AvxVector left, AvxVector right, AvxVector result)
    {
        if (left._array.Length != right._array.Length || left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, left._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_right = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_right = Vector256.LoadUnsafe(ref current_right);
            var v_result = Vector256.Add(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_right = ref Unsafe.Add(ref current_right, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] + right._array[i];
    } // public static void Add (AvxVector, AvxVector, AvxVector)

    /// <summary>
    /// Adds the specified value to the specified vector and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The left vector.</param>
    /// <param name="right">The value to add.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Add(AvxVector left, double right, AvxVector result)
    {
        ref var begin_l = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_l = ref Unsafe.Add(ref begin_l, left._array.Length - Vector256<double>.Count);

        ref var current_l = ref begin_l;
        ref var current_r = ref MemoryMarshal.GetArrayDataReference(result._array);

        var v_right = Vector256.Create(right);

        while (Unsafe.IsAddressLessThan(ref current_l, ref to_l))
        {
            var v_left = Vector256.LoadUnsafe(ref current_l);
            var v_result = Vector256.Add(v_left, v_right);
            v_result.StoreUnsafe(ref current_r);
            current_l = ref Unsafe.Add(ref current_l, Vector256<double>.Count);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] + right;
    } // public static void Add (AvxVector, double, AvxVector)

    /// <summary>
    /// Subtracts the specified vectors and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The vector to subtract from.</param>
    /// <param name="right">The vector to subtract.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Subtract(AvxVector left, AvxVector right, AvxVector result)
    {
        if (left._array.Length != right._array.Length || left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, left._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_right = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_right = Vector256.LoadUnsafe(ref current_right);
            var v_result = Vector256.Subtract(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_right = ref Unsafe.Add(ref current_right, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] - right._array[i];
    } // public static void Subtract (AvxVector, AvxVector, AvxVector)

    /// <summary>
    /// Subtracts the specified value from the specified vector and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The vector to subtract from.</param>
    /// <param name="right">The value to subtract.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Subtract(AvxVector left, double right, AvxVector result)
    {
        if (left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_l = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_l = ref Unsafe.Add(ref begin_l, left._array.Length - Vector256<double>.Count);

        ref var current_l = ref begin_l;
        ref var current_r = ref MemoryMarshal.GetArrayDataReference(result._array);

        var v_right = Vector256.Create(right);

        while (Unsafe.IsAddressLessThan(ref current_l, ref to_l))
        {
            var v_left = Vector256.LoadUnsafe(ref current_l);
            var v_result = Vector256.Subtract(v_left, v_right);
            v_result.StoreUnsafe(ref current_r);
            current_l = ref Unsafe.Add(ref current_l, Vector256<double>.Count);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] - right;
    } // public static void Subtract (AvxVector, double, AvxVector)

    /// <summary>
    /// Subtracts the specified vector from the specified value and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The value to subtract from.</param>
    /// <param name="right">The vector to subtract.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Subtract(double left, AvxVector right, AvxVector result)
    {
        if (right._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        var v_left = Vector256.Create(left);

        ref var begin_r = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var to_r = ref Unsafe.Add(ref begin_r, right._array.Length - Vector256<double>.Count);

        ref var current_r = ref begin_r;
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_r, ref to_r))
        {
            var v_right = Vector256.LoadUnsafe(ref current_r);
            var v_result = Vector256.Subtract(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(right);
        for (var i = offset; i < right._array.Length; i++)
            result._array[i] = left - right._array[i];
    } // public static void Subtract (double, AvxVector, AvxVector)

    /// <summary>
    /// Multiplies the specified vectors and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The left vector.</param>
    /// <param name="right">The right vector.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Multiply(AvxVector left, AvxVector right, AvxVector result)
    {
        if (left._array.Length != right._array.Length || left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, left._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_right = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_right = Vector256.LoadUnsafe(ref current_right);
            var v_result = Vector256.Multiply(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_right = ref Unsafe.Add(ref current_right, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] * right._array[i];
    } // public static void Multiply (AvxVector, AvxVector, AvxVector)

    /// <summary>
    /// The specified value to the specified vector and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The left vector.</param>
    /// <param name="right">The value to multiply.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Multiply(AvxVector left, double right, AvxVector result)
    {
        if (left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_l = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_l = ref Unsafe.Add(ref begin_l, left._array.Length - Vector256<double>.Count);

        ref var current_l = ref begin_l;
        ref var current_r = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_l, ref to_l))
        {
            var v_left = Vector256.LoadUnsafe(ref current_l);
            var v_result = Vector256.Multiply(v_left, right);
            v_result.StoreUnsafe(ref current_r);
            current_l = ref Unsafe.Add(ref current_l, Vector256<double>.Count);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] * right;
    } // public static void Multiply (AvxVector, double, AvxVector)

    /// <summary>
    /// Divides the specified vectors and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The vector to divide.</param>
    /// <param name="right">The vector to divide by.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Divide(AvxVector left, AvxVector right, AvxVector result)
    {
        if (left._array.Length != right._array.Length || left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, left._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_right = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_right = Vector256.LoadUnsafe(ref current_right);
            var v_result = Vector256.Divide(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_right = ref Unsafe.Add(ref current_right, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] / right._array[i];
    } // public static void Divide (AvxVector, AvxVector, AvxVector)

    /// <summary>
    /// Divides the specified vector by the specified value and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The vector to divide.</param>
    /// <param name="right">The value to divide by.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Divide(AvxVector left, double right, AvxVector result)
    {
        if (left._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_l = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_l = ref Unsafe.Add(ref begin_l, left._array.Length - Vector256<double>.Count);

        ref var current_l = ref begin_l;
        ref var current_r = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_l, ref to_l))
        {
            var v_left = Vector256.LoadUnsafe(ref current_l);
            var v_result = Vector256.Divide(v_left, right);
            v_result.StoreUnsafe(ref current_r);
            current_l = ref Unsafe.Add(ref current_l, Vector256<double>.Count);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            result._array[i] = left._array[i] / right;
    } // public static void Divide (AvxVector, double, AvxVector)

    /// <summary>
    /// Divides the specified value by the specified vector and stores the result in the specified vector.
    /// </summary>
    /// <param name="left">The value to divide.</param>
    /// <param name="right">The vector to divide by.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Divide(double left, AvxVector right, AvxVector result)
    {
        if (right._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        var v_left = Vector256.Create(left);

        ref var begin_r = ref MemoryMarshal.GetArrayDataReference(right._array);
        ref var to_r = ref Unsafe.Add(ref begin_r, right._array.Length - Vector256<double>.Count);

        ref var current_r = ref begin_r;
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_r, ref to_r))
        {
            var v_right = Vector256.LoadUnsafe(ref current_r);
            var v_result = Vector256.Divide(v_left, v_right);
            v_result.StoreUnsafe(ref current_result);
            current_r = ref Unsafe.Add(ref current_r, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(right);
        for (var i = offset; i < right._array.Length; i++)
            result._array[i] = left / right._array[i];
    } // public static void Divide (double, AvxVector, AvxVector)

    /// <summary>
    /// Computes the inner product of the specified vectors.
    /// </summary>
    /// <param name="left">The left vector.</param>
    /// <param name="right">The right vector.</param>
    /// <returns></returns>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    public static double InnerProduct(AvxVector left, AvxVector right)
    {
        if (left._array.Length != right._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(left._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, left._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_right = ref MemoryMarshal.GetArrayDataReference(right._array);

        var sums = Vector256<double>.Zero;
        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_right = Vector256.LoadUnsafe(ref current_right);
            sums += Vector256.Multiply(v_left, v_right);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_right = ref Unsafe.Add(ref current_right, Vector256<double>.Count);
        }

        var sum = Vector256.Sum(sums);
        var offset = GetRemainingOffset(left);
        for (var i = offset; i < left._array.Length; i++)
            sum += left._array[i] * right._array[i];

        return sum;
    } // public static double InnerProduct (AvxVector, AvxVector)

    /// <summary>
    /// Computes the exponential function for each element of the specified vector.
    /// </summary>
    /// <param name="vector">The vector.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Exp(AvxVector vector, AvxVector result)
    {
        if (vector._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(vector._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, vector._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_result = MathUtils.Exp(v_left);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(vector);
        for (var i = offset; i < vector._array.Length; i++)
            result._array[i] = MathUtils.FastExp(vector._array[i]);
    } // public static void Exp (AvxVector, AvxVector)

    /// <summary>
    /// Computes the exponential decay for each element of the specified vector.
    /// </summary>
    /// <param name="time">The time vector.</param>
    /// <param name="amplitude">The amplitude.</param>
    /// <param name="timeConstant">The time constant.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    /// <remarks>
    /// This method is slightly faster than the combination of the <see cref="Exp"/> and <see cref="Multiply"/> methods
    /// because the memory access is sequential.
    /// </remarks>
    public static void ExpDecay(AvxVector time, double amplitude, double timeConstant, AvxVector result)
    {
        if (time._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_time = ref MemoryMarshal.GetArrayDataReference(time._array);
        ref var to_time = ref Unsafe.Add(ref begin_time, time._array.Length - Vector256<double>.Count);

        ref var current_time = ref begin_time;
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        var t = -1.0 / timeConstant;
        while (Unsafe.IsAddressLessThan(ref current_time, ref to_time))
        {
            var v_time = Vector256.LoadUnsafe(ref current_time);
            var v_result = amplitude * MathUtils.Exp(t * v_time);
            v_result.StoreUnsafe(ref current_result);
            current_time = ref Unsafe.Add(ref current_time, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(time);
        for (var i = offset; i < time._array.Length; i++)
            result._array[i] = amplitude * MathUtils.FastExp(time._array[i] * t);
    } // public static void ExpDecay (AvxVector, double, double, AvxVector)

    /// <summary>
    /// Computes the natural logarithm for each element of the specified vector.
    /// </summary>
    /// <param name="vector">The vector.</param>
    /// <param name="result">The vector to store the result.</param>
    /// <exception cref="ArgumentException">The count of the vectors must be the same.</exception>
    /// <exception cref="InvalidOperationException">The <paramref name="result"/> vector is readonly.</exception>
    public static void Sqrt(AvxVector vector, AvxVector result)
    {
        if (vector._array.Length != result._array.Length)
            throw new ArgumentException("The count of the vectors must be the same.");
        if (result.IsReadonly)
            throw new InvalidOperationException("The result vector is readonly.");

        ref var begin_left = ref MemoryMarshal.GetArrayDataReference(vector._array);
        ref var to_left = ref Unsafe.Add(ref begin_left, vector._array.Length - Vector256<double>.Count);

        ref var current_left = ref begin_left;
        ref var current_result = ref MemoryMarshal.GetArrayDataReference(result._array);

        while (Unsafe.IsAddressLessThan(ref current_left, ref to_left))
        {
            var v_left = Vector256.LoadUnsafe(ref current_left);
            var v_result = Vector256.Sqrt(v_left);
            v_result.StoreUnsafe(ref current_result);
            current_left = ref Unsafe.Add(ref current_left, Vector256<double>.Count);
            current_result = ref Unsafe.Add(ref current_result, Vector256<double>.Count);
        }

        var offset = GetRemainingOffset(vector);
        for (var i = offset; i < vector._array.Length; i++)
            result._array[i] = Math.Sqrt(vector._array[i]);
    } // public static void Sqrt (AvxVector, AvxVector)

    /// <summary>
    /// Gets the remaining offset after the vectorized operations.
    /// </summary>
    /// <param name="vector">The vector.</param>
    /// <returns>The remaining offset after the vectorized operations.</returns>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static int GetRemainingOffset(AvxVector vector)
        => (vector._array.Length / Vector256<double>.Count) * Vector256<double>.Count;
} // public sealed class AvxVector
