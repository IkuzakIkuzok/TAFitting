
// (c) 2025 Kazuki Kohzuki

using SourceGeneratorUtils;
using System.Collections.Immutable;

namespace DisposalGenerator.Generators;

[Generator(LanguageNames.CSharp)]
internal sealed class AutoDisposalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sources = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttributesGenerator.Namespace + "." + AttributesGenerator.AutoDisposalAttributeName,
            static (node, token) => true,
            static (context, token) => context
        ).Collect();
        context.RegisterSourceOutput(sources, Execute);
    } // public void Initialize (GeneratorInitializationContext)

    private static void Execute(SourceProductionContext context, ImmutableArray<GeneratorAttributeSyntaxContext> sources)
    {
        if (sources.Length == 0) return;

        var compilation = sources.First().SemanticModel.Compilation;

        var disposableInterfaceSymbol = compilation.GetTypeByMetadataName("System.IDisposable");
        if (disposableInterfaceSymbol is null) return;

        var builder = new StringBuilder("// <auto-generated/>\n");
        foreach (var type in sources)
        {
            try
            {
                var typeSymbol = (INamedTypeSymbol)type.TargetSymbol;
                var nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
                var className = typeSymbol.Name;

                if (type.TargetNode is not ClassDeclarationSyntax classDeclaration) continue;

                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var fields =
                    classDeclaration.Members.OfType<FieldDeclarationSyntax>()
                                            .Where(f => IsDisposable(f, model, disposableInterfaceSymbol))
                                            .ToList();

                var attr = type.Attributes.First(attr => attr.AttributeClass?.Name == AttributesGenerator.AutoDisposalAttributeName);
                var namedArgs = attr.NamedArguments;
                var unmanagedDisposalMethod = namedArgs.FirstOrDefault(a => a.Key == "UnmanagedDisposalMethod").Value.Value?.ToString();

                if (fields.Count == 0 && string.IsNullOrEmpty(unmanagedDisposalMethod)) continue;

                var hasDisposeMethod = HasDisposeMethod(classDeclaration, model, disposableInterfaceSymbol);
                var hasDisposeMethodWithBool = HasDisposeMethodWithBool(classDeclaration, model);

                var isSealed = classDeclaration.Modifiers.Any(SyntaxKind.SealedKeyword);

                var baseNames = classDeclaration.BaseList?.Types.Select(t => model.GetTypeInfo(t.Type).Type?.Name) ?? [];

                builder.Append(
                    Generate(
                        nameSpace, className,
                        fields,
                        string.Join(", ", baseNames),
                        hasDisposeMethod, hasDisposeMethodWithBool,
                        isSealed,
                        unmanagedDisposalMethod
                    )
                );
            }
            catch
            {

            }
        }

        var code = builder.ToString().NormalizeNewLines();
        context.AddSource("AutoDisposal.g.cs", code);
    } // private static void Execute (SourceProductionContext, ImmutableArray<GeneratorAttributeSyntaxContext>)

    private static string Generate(string nameSpace, string className, IReadOnlyCollection<FieldDeclarationSyntax> fields, string baseNames, bool hasDispose, bool hasDisposeBool, bool isSealed, string? unmanaged)
    {
        var builder = new StringBuilder();

        builder.AppendLine();
        builder.AppendLine($"namespace {nameSpace}");
        builder.AppendLine("{");

        if (hasDisposeBool)
            builder.AppendLine($"\tpartial class {className} : {baseNames}");
        else
            builder.AppendLine($"\tpartial class {className} : global::System.IDisposable");
        builder.AppendLine("\t{");

        builder.AppendLine("\t\tprivate bool disposed = false;");
        builder.AppendLine();

        if (!hasDispose)
        {
            builder.AppendLine("\t\tpublic void Dispose()");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tDispose(true);");
            builder.AppendLine("\t\t\tglobal::System.GC.SuppressFinalize(this);");
            builder.AppendLine("\t\t} // public void Dispose()");
            builder.AppendLine();
        }

        var m = isSealed ? "private" : "protected virtual";
        if (hasDisposeBool)
        {
            builder.AppendLine("\t\toverride protected void Dispose(bool disposing)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (this.disposed) return;");
            builder.AppendLine("\t\t\tbase.Dispose(disposing);");
        }
        else
        {
            builder.AppendLine($"\t\t{m} void Dispose(bool disposing)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (disposed) return;");
        }

        builder.AppendLine();
        builder.AppendLine("\t\t\tdisposed = true;");
        foreach (var field in fields.SelectMany(f => f.Declaration.Variables))
        {
            var name = field.Identifier.Text;
            builder.AppendLine($"\t\t\tthis.{name}?.Dispose();");
        }

        if (!string.IsNullOrEmpty(unmanaged))
        {
            builder.AppendLine();
            builder.AppendLine($"\t\t\t{unmanaged}();");
        }

        if (hasDisposeBool)
            builder.AppendLine("\t\t} // override protected void Dispose (bool)");
        else
            builder.AppendLine($"\t\t}} // {m} void Dispose (bool)");

        if (hasDispose)
            builder.AppendLine($"\t}} // partial class {className} : {baseNames}");
        else
            builder.AppendLine($"\t}} // partial class {className} : global::.System.IDisposable");
        builder.AppendLine("} // namespace " + nameSpace);

        return builder.ToString();
    } // private static string Generate(string, string, IReadOnlyCollection<FieldDeclarationSyntax>, string, bool, bool, bool, string?)

    private static readonly string[] attrs = [AttributesGenerator.NotToBeDisposedAttributeName, AttributesGenerator.NotToBeDisposedAttributeShortName];
    private static bool IsDisposable(FieldDeclarationSyntax field, SemanticModel model, INamedTypeSymbol interfaceSymbol)
    {
        var isStatic = field.Modifiers.Any(SyntaxKind.StaticKeyword);
        if (isStatic) return false;

        var hasExplicitDisposalAttribute = field.AttributeLists
            .SelectMany(al => al.Attributes)
            .Select(a => a.Name.ToFullString().Split('.').Last())
            .Any(n => attrs.Contains(n));
        if (hasExplicitDisposalAttribute) return false;

        var type = model.GetTypeInfo(field.Declaration.Type).Type;
        return type is not null && type.AllInterfaces.Contains(interfaceSymbol);
    } //  private static bool IsDisposable (FieldDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool HasDisposeMethod(ClassDeclarationSyntax cls, SemanticModel model, INamedTypeSymbol interfaceSymbol)
    {
        foreach (var t in cls.BaseList?.Types.Select(t => t.Type) ?? [])
        {
            var type = model.GetTypeInfo(t).Type;
            if (type is null) continue;
            if (type.AllInterfaces.Contains(interfaceSymbol)) return true;
        }
        return false;
    } // private static bool HasDisposeMethod (ClassDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool HasDisposeMethodWithBool(ClassDeclarationSyntax cls, SemanticModel model)
    {
        foreach (var t in cls.BaseList?.Types.Select(t => t.Type) ?? [])
        {
            var baseType = model.GetTypeInfo(t).Type;
            if (baseType is null) return false;
            var disposeMethod = baseType.GetMembers("Dispose").OfType<IMethodSymbol>().FirstOrDefault();
            if (disposeMethod is null) continue;
            if (disposeMethod.ReturnsVoid && disposeMethod.Parameters.Length == 1 && disposeMethod.Parameters[0].Type.SpecialType == SpecialType.System_Boolean)
                return true;
        }
        return false;
    } // private static bool HasDisposeMethodWithBool (ClassDeclarationSyntax, SemanticModel, INamedTypeSymbol)
} // internal sealed class AutoDisposalGenerator : IIncrementalGenerator
