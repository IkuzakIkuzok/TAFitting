
// (c) 2025 Kazuki Kohzuki

using TAFitting.SourceGeneratorUtils;

namespace DisposalGenerator.Generators;

[Generator(LanguageNames.CSharp)]
internal sealed class AutoDisposalGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new AttributeSyntaxReceiver(AttributesGenerator.AutoDisposalAttributeName));
    } // public void Initialize (GeneratorInitializationContext)

    public void Execute(GeneratorExecutionContext context)
    {
        if (context.SyntaxReceiver is not AttributeSyntaxReceiver receiver) return;

        if (receiver.Classes.Count == 0) return;

        var disposableInterfaceSymbol = context.Compilation.GetTypeByMetadataName("System.IDisposable");
        if (disposableInterfaceSymbol is null) return;

        var builder = new StringBuilder("// <auto-generated/>\n");
        foreach (var cls in receiver.Classes)
        {
            try
            {
                var classDeclaration = cls.Target;
                var attr = cls.Attribute;
                (var nameSpace, var className) = GetFullyQualifiedName(context, classDeclaration);

                var model = context.Compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var fields =
                    classDeclaration.Members.OfType<FieldDeclarationSyntax>()
                                            .Where(f => IsDisposable(f, model, disposableInterfaceSymbol))
                                            .ToList();
                
                var unmanagedDisposalMethod = GetUnmanagedDisposalMethod(attr);

                if (fields.Count == 0 && string.IsNullOrEmpty(unmanagedDisposalMethod)) continue;
                
                var hasDisposeMethod = HasDisposeMethod(classDeclaration, model, disposableInterfaceSymbol);
                var hasDisposeMethodWithBool = HasDisposeMethodWithBool(classDeclaration, model);

                var isSealed = classDeclaration.Modifiers.Any(SyntaxKind.SealedKeyword);

                var baseNames = classDeclaration.BaseList?.Types.Select(t => model.GetTypeInfo(t.Type).Type?.Name) ?? [];

                builder.Append(
                    Generate(
                        nameSpace, className,
                        fields,
                        string.Join(", ", baseNames),
                        hasDisposeMethod, hasDisposeMethodWithBool,
                        isSealed,
                        unmanagedDisposalMethod
                    )
                );
            }
            catch
            {

            }
        }

        var source = builder.ToString().NormalizeNewLines();
        if (string.IsNullOrWhiteSpace(source)) return;
        context.AddSource("AutoDisposal.g.cs", source);
    } // public void Execute (GeneratorExecutionContext)

    private static string Generate(string nameSpace, string className, IReadOnlyCollection<FieldDeclarationSyntax> fields, string baseNames, bool hasDispose, bool hasDisposeBool, bool isSealed, string? unmanaged)
    {
        var builder = new StringBuilder();

        builder.AppendLine();
        builder.AppendLine($"namespace {nameSpace}");
        builder.AppendLine("{");

        if (hasDisposeBool)
            builder.AppendLine($"\tpartial class {className} : {baseNames}");
        else
            builder.AppendLine($"\tpartial class {className} : IDisposable");
        builder.AppendLine("\t{");

        builder.AppendLine("\t\tprivate bool disposed = false;");
        builder.AppendLine();

        if (!hasDispose)
        {
            builder.AppendLine("\t\tpublic void Dispose()");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tDispose(true);");
            builder.AppendLine("\t\t\tGC.SuppressFinalize(this);");
            builder.AppendLine("\t\t} // public void Dispose()");
            builder.AppendLine();
        }

        var m = isSealed ? "private" : "protected virtual";
        if (hasDisposeBool)
        {
            builder.AppendLine("\t\toverride protected void Dispose(bool disposing)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (this.disposed) return;");
            builder.AppendLine("\t\t\tbase.Dispose(disposing);");
        }
        else
        {
            builder.AppendLine($"\t\t{m} void Dispose(bool disposing)");
            builder.AppendLine("\t\t{");
            builder.AppendLine("\t\t\tif (disposed) return;");
        }

        builder.AppendLine();
        builder.AppendLine("\t\t\tdisposed = true;");
        foreach (var field in fields.SelectMany(f => f.Declaration.Variables))
        {
            var name = field.Identifier.Text;
            builder.AppendLine($"\t\t\tthis.{name}?.Dispose();");
        }

        if (!string.IsNullOrEmpty(unmanaged))
        {
            builder.AppendLine();
            builder.AppendLine($"\t\t\t{unmanaged}();");
        }

        if (hasDisposeBool)
            builder.AppendLine("\t\t} // override protected void Dispose (bool)");
        else
            builder.AppendLine($"\t\t}} // {m} void Dispose (bool)");

        if (hasDispose)
            builder.AppendLine($"\t}} // partial class {className} : {baseNames}");
        else
            builder.AppendLine($"\t}} // partial class {className} : IDisposable");
        builder.AppendLine("} // namespace " + nameSpace);

        return builder.ToString();
    } // private static string Generate(string, string, IReadOnlyCollection<FieldDeclarationSyntax>, string, bool, bool, bool, string?)

    private static readonly string[] attrs = [AttributesGenerator.NotToBeDisposedAttributeName, AttributesGenerator.NotToBeDisposedAttributeShortName];
    private static bool IsDisposable(FieldDeclarationSyntax field, SemanticModel model, INamedTypeSymbol interfaceSymbol)
    {
        var isStatic = field.Modifiers.Any(SyntaxKind.StaticKeyword);
        if (isStatic) return false;

        var hasExplicitDisposalAttribute = field.AttributeLists
            .SelectMany(al => al.Attributes)
            .Select(a => a.Name.ToFullString().Split('.').Last())
            .Any(n => attrs.Contains(n));
        if (hasExplicitDisposalAttribute) return false;

        var type = model.GetTypeInfo(field.Declaration.Type).Type;
        return type is not null && type.AllInterfaces.Contains(interfaceSymbol);
    } //  private static bool IsDisposable (FieldDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool HasDisposeMethod(ClassDeclarationSyntax cls, SemanticModel model, INamedTypeSymbol interfaceSymbol)
    {
        foreach (var t in cls.BaseList?.Types.Select(t => t.Type) ?? [])
        {
            var type = model.GetTypeInfo(t).Type;
            if (type is null) continue;
            if (type.AllInterfaces.Contains(interfaceSymbol)) return true;
        }
        return false;
    } // private static bool HasDisposeMethod (ClassDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool HasDisposeMethodWithBool(ClassDeclarationSyntax cls, SemanticModel model)
    {
        foreach (var t in cls.BaseList?.Types.Select(t => t.Type) ?? [])
        {
            var baseType = model.GetTypeInfo(t).Type;
            if (baseType is null) return false;
            var disposeMethod = baseType.GetMembers("Dispose").OfType<IMethodSymbol>().FirstOrDefault();
            if (disposeMethod is null) continue;
            if (disposeMethod.ReturnsVoid && disposeMethod.Parameters.Length == 1 && disposeMethod.Parameters[0].Type.SpecialType == SpecialType.System_Boolean)
                return true;
        }
        return false;
    } // private static bool HasDisposeMethodWithBool (ClassDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    /// <summary>
    /// Gets the fully qualified name of the class.
    /// </summary>
    /// <param name="context">The context</param>
    /// <param name="cls">The class declaration syntax.</param>
    /// <returns>The fully qualified name of the class.</returns>
    /// <exception cref="Exception">Failed to get the symbol of the class.</exception>
    private static (string, string) GetFullyQualifiedName(GeneratorExecutionContext context, ClassDeclarationSyntax cls)
    {
        var typeSymbol =
            context.Compilation
                   .GetSemanticModel(cls.SyntaxTree)
                   .GetDeclaredSymbol(cls)
            ?? throw new Exception("Failed to get the symbol of the class.");
        var nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
        var className = typeSymbol.Name;
        return (nameSpace, className);
    } // protected virtual (string, string) GetFullyQualifiedName (GeneratorExecutionContext, ClassDeclarationSyntax)

    private static string? GetUnmanagedDisposalMethod(AttributeSyntax attribute)
    {
        var args = attribute.ArgumentList?.Arguments.Cast<AttributeArgumentSyntax>();
        var arg = args?.FirstOrDefault();
        if (arg is null) return null;

        // string literal
        if (arg.Expression is LiteralExpressionSyntax literal)
            return literal.Token.ValueText;

        // nameof expression (invocation expression with nameof)
        if (arg.Expression is InvocationExpressionSyntax invocation)
        {
            var ia = invocation.ArgumentList.Arguments.FirstOrDefault();
            if (ia is null) return null;
            if (ia.Expression is not IdentifierNameSyntax identifier) return null;
            return identifier.Identifier.Text;
        }

        return null;
    } // private static string? GetUnmanagedDisposalMethod (GeneratorExecutionContext, AttributeSyntax)
} // internal sealed class AutoDisposalGenerator : ISourceGenerator
