
// (c) 2025-2026 Kazuki Kohzuki

using SourceGeneratorUtils;
using System.Collections.Immutable;

namespace DisposalGenerator.Generators;

[Generator(LanguageNames.CSharp)]
internal sealed class AutoDisposalGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var sources = context.SyntaxProvider.ForAttributeWithMetadataName(
            AttributesGenerator.Namespace + "." + AttributesGenerator.AutoDisposalAttributeName,
            static (node, token) => node is ClassDeclarationSyntax or StructDeclarationSyntax,
            static (context, token) => context
        ).Collect();
        context.RegisterSourceOutput(sources, Execute);
    } // public void Initialize (GeneratorInitializationContext)

    private static void Execute(SourceProductionContext context, ImmutableArray<GeneratorAttributeSyntaxContext> sources)
    {
        if (sources.Length == 0) return;

        var compilation = sources.First().SemanticModel.Compilation;

        var disposableInterfaceSymbol = compilation.GetTypeByMetadataName("System.IDisposable");
        if (disposableInterfaceSymbol is null) return;

        var builder = new StringBuilder("// <auto-generated/>\n");
        foreach (var type in sources)
        {
            try
            {
                var typeSymbol = (INamedTypeSymbol)type.TargetSymbol;
                var nameSpace = typeSymbol.ContainingNamespace.ToDisplayString();
                var className = typeSymbol.Name;

                if (type.TargetNode is not ClassDeclarationSyntax classDeclaration) continue;

                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var fields =
                    classDeclaration.Members.OfType<FieldDeclarationSyntax>()
                                            .Where(f => IsDisposable(f, model, disposableInterfaceSymbol))
                                            .ToList();

                var attr = type.Attributes.First(attr => attr.AttributeClass?.Name == AttributesGenerator.AutoDisposalAttributeName);
                var namedArgs = attr.NamedArguments;
                var unmanagedDisposalMethod = namedArgs.FirstOrDefault(a => a.Key == "UnmanagedDisposalMethod").Value.Value?.ToString();

                if (fields.Count == 0 && string.IsNullOrEmpty(unmanagedDisposalMethod)) continue;

                var hasDisposeMethod = HasDisposeMethod(classDeclaration, model);
                var hasDisposeMethodWithBool = HasDisposeMethodWithBool(classDeclaration, model);

                var isSealed = classDeclaration.Modifiers.Any(SyntaxKind.SealedKeyword);

                var baseNames = classDeclaration.BaseList?.Types.Select(t => model.GetTypeInfo(t.Type).Type?.Name) ?? [];

                Generate(
                    builder,
                    nameSpace, className,
                    fields,
                    string.Join(", ", baseNames),
                    hasDisposeMethod, hasDisposeMethodWithBool,
                    isSealed,
                    unmanagedDisposalMethod
                );
            }
            catch
            {

            }
        }

        var code = builder.NormalizeNewLines().ToString();
        context.AddSource("AutoDisposal.g.cs", code);
    } // private static void Execute (SourceProductionContext, ImmutableArray<GeneratorAttributeSyntaxContext>)

    private static void Generate(StringBuilder builder, string nameSpace, string className, IReadOnlyCollection<FieldDeclarationSyntax> fields, string baseNames, bool hasDispose, bool hasDisposeBool, bool isSealed, string? unmanaged)
    {
        builder.AppendLine();
        builder.AppendLine($"namespace {nameSpace}");
        builder.AppendLine("{");

        if (hasDisposeBool)
            builder.AppendLine($"\tpartial class {className} : {baseNames}");
        else
            builder.AppendLine($"\tpartial class {className} : global::System.IDisposable");
        builder.AppendLine("\t{");

        builder.AppendLine("\t\t[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]");
        builder.AppendLine("\t\t[global::System.Diagnostics.DebuggerBrowsable(global::System.Diagnostics.DebuggerBrowsableState.Never)]");
        builder.AppendLine("\t\t[global::System.Runtime.CompilerServices.CompilerGenerated]");
        builder.AppendLine("\t\tprivate bool __generated_disposed = false;");

        var canBeSimple =
            !hasDispose &&                    // No Dispose() method
            !hasDisposeBool &&                // No base Dispose(bool) method
            isSealed &&                       // Sealed class (not inheritable)
            string.IsNullOrEmpty(unmanaged);  // No unmanaged disposal method

        if (canBeSimple)
            GenerateSimpleDispose(builder, fields);
        else
            GenerateInheritableDispose(builder, className, fields, hasDispose, hasDisposeBool, isSealed, unmanaged);

        if (hasDispose)
            builder.AppendLine($"\t}} // partial class {className} : {baseNames}");
        else
            builder.AppendLine($"\t}} // partial class {className} : global::.System.IDisposable");

        builder.AppendLine("} // namespace " + nameSpace);
    } // private static void Generate(StringBuilder, string, string, IReadOnlyCollection<FieldDeclarationSyntax>, string, bool, bool, bool, string?)

    private static void GenerateSimpleDispose(StringBuilder builder, IReadOnlyCollection<FieldDeclarationSyntax> fields)
    {
        builder.AppendLine(@"
        public void Dispose()
        {
            if (this.__generated_disposed) return;
        ");

        foreach (var field in fields.SelectMany(f => f.Declaration.Variables))
        {
            var name = field.Identifier.Text;
            builder.AppendLine($"\t\t\tthis.{name}?.Dispose();");
        }
        builder.AppendLine(@"
            this.__generated_disposed = true;
        } // public void Dispose ()");
    } // private static void GenerateSimpleDispose (StringBuilder, IReadOnlyCollection<FieldDeclarationSyntax>)

    private static void GenerateInheritableDispose(StringBuilder builder, string className, IReadOnlyCollection<FieldDeclarationSyntax> fields, bool hasDispose, bool hasDisposeBool, bool isSealed, string? unmanaged)
    {
        if (!hasDispose && !hasDisposeBool)
        {
            builder.AppendLine(@"
        public void Dispose()
        {
            Dispose(true);");

            if (!string.IsNullOrEmpty(unmanaged))
            {
                builder.Append("\t\t\tglobal::System.GC.SuppressFinalize(this);");
            }

            builder.AppendLine(@"
        } // public void Dispose ()");
        }

        var m = isSealed ? "private" : "protected virtual";
        if (hasDisposeBool)
        {
            builder.AppendLine(@"
        override protected void Dispose(bool disposing)
        {
            if (this.__generated_disposed) return;
            base.Dispose(disposing);");
        }
        else
        {
            builder.AppendLine($@"
        {m} void Dispose(bool disposing)
        {{
            if (this.__generated_disposed) return;");
        }

        if (fields.Count > 0)
        {
            builder.AppendLine();
            builder.AppendLine("\t\t\tif (disposing)\n\t\t\t{");
            foreach (var field in fields.SelectMany(f => f.Declaration.Variables))
            {
                var name = field.Identifier.Text;
                builder.AppendLine($"\t\t\t\tthis.{name}?.Dispose();");
            }
            builder.AppendLine("\t\t\t}"); // if (disposing)
        }
        
        if (!string.IsNullOrEmpty(unmanaged))
        {
            builder.AppendLine();
            builder.AppendLine($"\t\t\t{unmanaged}();");
        }

        builder.AppendLine();
        builder.AppendLine("\t\t\tthis.__generated_disposed = true;");

        if (hasDisposeBool)
            builder.AppendLine("\t\t} // override protected void Dispose (bool)");
        else
            builder.AppendLine($"\t\t}} // {m} void Dispose (bool)");

        if (!string.IsNullOrEmpty(unmanaged))
        {
            builder.AppendLine($@"
        ~{className}()
        {{
            Dispose(false);
        }} // ~{className} ()");
        }
    } // private static void GenerateInheritableDispose (StringBuilder, IReadOnlyCollection<FieldDeclarationSyntax>, bool, bool, bool, string?)

    private static readonly string[] attrs = [AttributesGenerator.NotToBeDisposedAttributeName, AttributesGenerator.NotToBeDisposedAttributeShortName];
    private static bool IsDisposable(FieldDeclarationSyntax field, SemanticModel model, INamedTypeSymbol interfaceSymbol)
    {
        var isStatic = field.Modifiers.Any(SyntaxKind.StaticKeyword);
        if (isStatic) return false;

        var hasExplicitDisposalAttribute = field.AttributeLists
            .SelectMany(al => al.Attributes)
            .Select(a => a.Name.ToFullString().Split('.').Last())
            .Any(n => attrs.Contains(n));
        if (hasExplicitDisposalAttribute) return false;

        var type = model.GetTypeInfo(field.Declaration.Type).Type;
        return type is not null && type.AllInterfaces.Contains(interfaceSymbol);
    } //  private static bool IsDisposable (FieldDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool HasDisposeMethod(ClassDeclarationSyntax cls, SemanticModel model)
    {
        var methods =
            cls.Members.OfType<MethodDeclarationSyntax>()
                       .Where(m => m.Identifier.Text == "Dispose")
                       .Select(m => model.GetDeclaredSymbol(m));
        return methods.Any(m => m is not null && m.ReturnsVoid && m.Parameters.Length == 0);
    } // private static bool HasDisposeMethod (ClassDeclarationSyntax, SemanticModel)

    private static bool HasDisposeMethodWithBool(ClassDeclarationSyntax cls, SemanticModel model)
    {
        foreach (var t in cls.BaseList?.Types.Select(t => t.Type) ?? [])
        {
            var baseType = model.GetTypeInfo(t).Type;
            if (baseType is null) return false;
            var disposeMethod = baseType.GetMembers().OfType<IMethodSymbol>().Where(IsDisposeMethodWithBool);
            if (disposeMethod.Any()) return true;
        }
        return false;
    } // private static bool HasDisposeMethodWithBool (ClassDeclarationSyntax, SemanticModel, INamedTypeSymbol)

    private static bool IsDisposeMethodWithBool(IMethodSymbol method)
        => method.Name == "Dispose"
        && method.ReturnsVoid
        && method.Parameters.Length == 1
        && method.Parameters[0].Type.SpecialType == SpecialType.System_Boolean;
} // internal sealed class AutoDisposalGenerator : IIncrementalGenerator
