
// (c) 2024 Kazuki Kohzuki

namespace TAFitting.SourceGeneratorUtils;

[Generator(LanguageNames.CSharp)]
internal sealed class NodeUtilsGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context) { }

    public void Execute(GeneratorExecutionContext context)
    {
        context.AddSource("NodeUtils.g.cs", NodeUtilsSource);
    } // public void Execute (GeneratorExecutionContext)

    private const string NodeUtilsSource = @"// <auto-generated/>

using Microsoft.CodeAnalysis.Diagnostics;

namespace TAFitting.SourceGeneratorUtils;

/// <summary>
/// Provides extension methods for <see cref=""SyntaxNode""/>.
/// </summary>
public static class SyntaxNodeUtils
{
    /// <summary>
    /// Gets the fully qualified name of the attribute.
    /// </summary>
    /// <param name=""attribute"">The attribute.</param>
    /// <param name=""context"">The context.</param>
    /// <returns>The fully qualified name.</returns>
    public static string GetGetFullyQualifiedName(this AttributeSyntax attribute, SyntaxNodeAnalysisContext context)
    {
        var symbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol;
        return symbol?.GetFullyQualifiedName() ?? string.Empty;
    } // public static string GetGetFullyQualifiedName (AttributeSyntax, SyntaxNodeAnalysisContext)

    /// <summary>
    /// Obtains the fully qualified name of the class.
    /// </summary>
    /// <param name=""symbol"">The symbol.</param>
    /// <returns>The fully qualified name.</returns>
    /// <remarks><see cref=""ISymbol.ToDisplayParts(SymbolDisplayFormat?)""/> with argument <see cref=""SymbolDisplayFormat.FullyQualifiedFormat""/>
    /// does NOT work as expected. This problem is already reported on <a href=""https://github.com/dotnet/roslyn/issues/50259"">GitHub</a>.</remarks>
    public static string GetFullyQualifiedName(this ISymbol symbol)
    {
        var definition = symbol.OriginalDefinition.DeclaringSyntaxReferences.FirstOrDefault()?.GetSyntax();
        if (definition == null) return symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var node = definition;
        var names = new List<string>();
        while ((node = node.Parent) != null)
        {
            if (node is NamespaceDeclarationSyntax ns)
                names.Add(ns.Name.ToString());
            if (node is ClassDeclarationSyntax @class)
                names.Add(@class.ChildTokens().Where(token => token.IsKind(SyntaxKind.IdentifierToken)).First().Text);
        }
        names.Reverse();
        return string.Join(""."", names);
    } // public static string GetFullyQualifiedName (this ISymbol)

    public static string NormalizeAttributeName(this string name)
    {
        if (name.EndsWith(""Attribute"", StringComparison.Ordinal)) return name;
        return name + ""Attribute"";
    } // public static string NormalizeAttributeName (this string)
} // public static class SyntaxNodeUtils
";
} // internal sealed class NodeUtilsGenerator : ISourceGenerator
