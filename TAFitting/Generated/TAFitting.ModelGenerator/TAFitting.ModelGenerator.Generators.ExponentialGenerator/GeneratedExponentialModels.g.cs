// <auto-generated/>

using System.Runtime.InteropServices;


using System.Runtime.CompilerServices;
using TAFitting.Data.Solver.SIMD;

file static class MathUtil
{
    private const int TABLE_SIZE = 11;
    private const int s = 1 << TABLE_SIZE;

    private static readonly ulong[] table;

    static MathUtil()
    {
        table = new ulong[s];
    } // cctor ()

    [ModuleInitializer]
    internal static void MakeTable()
    {
        var di = new DoubleUInt64();
        for (var i = 0UL; i < s; i++)
        {
            di.Double = Math.Pow(2, i * (1.0 / s));
            table[i] = di.UInt64 & Mask64(52);
        }
    } // private static void MakeTable ()

    private static ulong Mask64(int n) => (1UL << n) - 1;

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static double FastExp(double x)
    {
        if (x <= -708.396418532264) return 0;
        if (x >= 709.782712893384) return double.PositiveInfinity;

        var d = x * (2954.6394437406) + (6755399441055744);
        var i = BitConverter.DoubleToUInt64Bits(d);
        var iax = table[i & 2047];
        var t = (d - (6755399441055744)) * 0.000338450771757786 - x;
        var u = ((i + 2095104) >> 11) << 52;
        var y = (3.0000000027955394 - t) * (t * t) * 0.16666666685227835 - t + 1;
        i = u | iax;
        d = BitConverter.UInt64BitsToDouble(i);

        return d * y;
    } // internal static double FastExp (double)

    [StructLayout(LayoutKind.Explicit)]
    private struct DoubleUInt64
    {
        [FieldOffset(0)]
        public double Double = 0;

        [FieldOffset(0)]
        public ulong UInt64 = 0;

        public DoubleUInt64() { }
    } // private struct DoubleUInt64
} // file static class MathUtil


namespace TAFitting.Model.Exponential
{

	/// <summary>
	/// Represents a 1-component exponential model.
	/// </summary>
	internal partial class Exponential1 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
	{
		private static readonly Parameter[] parameters = [
			new() { Name = "A0", IsMagnitude = true },
			new() { Name = "A1", InitialValue = 1e2, IsMagnitude = true },
			new() { Name = "T1", InitialValue = 5e0, Constraints = ParameterConstraints.Positive },
		];

		/// <inheritdoc/>
		public string Name => "Exp1";

		/// <inheritdoc/>
		public string Description => "1-component exponential model";

		/// <inheritdoc/>
		public string ExcelFormula => "[A0] + [A1] * EXP(-$X / [T1])";

		/// <inheritdoc/>
		public IReadOnlyList<Parameter> Parameters => parameters;

		/// <inheritdoc/>
		public bool XLogScale => false;

		/// <inheritdoc/>
		public bool YLogScale => true;

		/// <inheritdoc/>
		public Func<double, double> GetFunction(IReadOnlyList<double> parameters)
		{
			var a0 = parameters[0];
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];

			return x => a0 + a1 * MathUtil.FastExp(x * t1);
		} // public Func<double, double> GetFunction(IReadOnlyList<double> parameters)

		/// <inheritdoc/>
		public Func<AvxVector2048, AvxVector2048> GetVectorizedFunc(IReadOnlyList<double> parameters)
			=> x => 
			{
				var length = x.Length << 2;
				var temp = AvxVector2048.Create(length);
				var a0 = AvxVector2048.Create(length, parameters[0]);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				AvxVector2048.Multiply(x, t1, temp);     // temp = -x / t1
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t1)
				AvxVector2048.Multiply(temp, a1, temp);  // temp = a1 * exp(-x / t1)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a1 * exp(-x / t1)

				return a0;
			};

		/// <inheritdoc/>
		public Action<double, double[]> GetDerivatives(IReadOnlyList<double> parameters)
		{
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];

			return (x, res) =>
			{
				var exp1 = MathUtil.FastExp(x * t1);

				var d_a0 = 1.0;
				var d_a1 = exp1;
				var d_t1 = a1 * x * exp1 * (t1 * t1);

				res[0] = d_a0;
				res[1] = d_a1;
				res[2] = d_t1;
			};
		} // public Action<double, double[]> GetDerivatives (IReadOnlyList<double>)

		/// <inheritdoc/>
		public Action<AvxVector2048, AvxVector2048[]> GetVectorizedDerivatives(IReadOnlyList<double> parameters)
			=> (x, res) =>
			{
				res[0].Load(1.0);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				// res[1] = exp(-x / t1)
				AvxVector2048.Multiply(x, t1, res[1]);
				AvxVector2048.Exp(res[1], res[1]);
				// res[2] = a1 * x * exp(-x / t1) / (t1 * t1)
				AvxVector2048.Multiply(res[1], a1 * t1 * t1, res[2]);
				AvxVector2048.Multiply(res[2], x, res[2]);
			};
	} // internal partial class Exponential1 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
} // namespace TAFitting.Model.Exponential


namespace TAFitting.Model.Exponential
{

	/// <summary>
	/// Represents a 2-component exponential model.
	/// </summary>
	internal partial class Exponential2 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
	{
		private static readonly Parameter[] parameters = [
			new() { Name = "A0", IsMagnitude = true },
			new() { Name = "A1", InitialValue = 1e2, IsMagnitude = true },
			new() { Name = "T1", InitialValue = 5e0, Constraints = ParameterConstraints.Positive },
			new() { Name = "A2", InitialValue = 1e1, IsMagnitude = true },
			new() { Name = "T2", InitialValue = 5e1, Constraints = ParameterConstraints.Positive },
		];

		/// <inheritdoc/>
		public string Name => "Exp2";

		/// <inheritdoc/>
		public string Description => "2-component exponential model";

		/// <inheritdoc/>
		public string ExcelFormula => "[A0] + [A1] * EXP(-$X / [T1]) + [A2] * EXP(-$X / [T2])";

		/// <inheritdoc/>
		public IReadOnlyList<Parameter> Parameters => parameters;

		/// <inheritdoc/>
		public bool XLogScale => false;

		/// <inheritdoc/>
		public bool YLogScale => true;

		/// <inheritdoc/>
		public Func<double, double> GetFunction(IReadOnlyList<double> parameters)
		{
			var a0 = parameters[0];
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];

			return x => a0 + a1 * MathUtil.FastExp(x * t1) + a2 * MathUtil.FastExp(x * t2);
		} // public Func<double, double> GetFunction(IReadOnlyList<double> parameters)

		/// <inheritdoc/>
		public Func<AvxVector2048, AvxVector2048> GetVectorizedFunc(IReadOnlyList<double> parameters)
			=> x => 
			{
				var length = x.Length << 2;
				var temp = AvxVector2048.Create(length);
				var a0 = AvxVector2048.Create(length, parameters[0]);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				AvxVector2048.Multiply(x, t1, temp);     // temp = -x / t1
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t1)
				AvxVector2048.Multiply(temp, a1, temp);  // temp = a1 * exp(-x / t1)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a1 * exp(-x / t1)

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				AvxVector2048.Multiply(x, t2, temp);     // temp = -x / t2
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t2)
				AvxVector2048.Multiply(temp, a2, temp);  // temp = a2 * exp(-x / t2)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a2 * exp(-x / t2)

				return a0;
			};

		/// <inheritdoc/>
		public Action<double, double[]> GetDerivatives(IReadOnlyList<double> parameters)
		{
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];

			return (x, res) =>
			{
				var exp1 = MathUtil.FastExp(x * t1);
				var exp2 = MathUtil.FastExp(x * t2);

				var d_a0 = 1.0;
				var d_a1 = exp1;
				var d_t1 = a1 * x * exp1 * (t1 * t1);
				var d_a2 = exp2;
				var d_t2 = a2 * x * exp2 * (t2 * t2);

				res[0] = d_a0;
				res[1] = d_a1;
				res[2] = d_t1;
				res[3] = d_a2;
				res[4] = d_t2;
			};
		} // public Action<double, double[]> GetDerivatives (IReadOnlyList<double>)

		/// <inheritdoc/>
		public Action<AvxVector2048, AvxVector2048[]> GetVectorizedDerivatives(IReadOnlyList<double> parameters)
			=> (x, res) =>
			{
				res[0].Load(1.0);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				// res[1] = exp(-x / t1)
				AvxVector2048.Multiply(x, t1, res[1]);
				AvxVector2048.Exp(res[1], res[1]);
				// res[2] = a1 * x * exp(-x / t1) / (t1 * t1)
				AvxVector2048.Multiply(res[1], a1 * t1 * t1, res[2]);
				AvxVector2048.Multiply(res[2], x, res[2]);

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				// res[3] = exp(-x / t2)
				AvxVector2048.Multiply(x, t2, res[3]);
				AvxVector2048.Exp(res[3], res[3]);
				// res[4] = a2 * x * exp(-x / t2) / (t2 * t2)
				AvxVector2048.Multiply(res[3], a2 * t2 * t2, res[4]);
				AvxVector2048.Multiply(res[4], x, res[4]);
			};
	} // internal partial class Exponential2 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
} // namespace TAFitting.Model.Exponential


namespace TAFitting.Model.Exponential
{

	/// <summary>
	/// Represents a 3-component exponential model.
	/// </summary>
	internal partial class Exponential3 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
	{
		private static readonly Parameter[] parameters = [
			new() { Name = "A0", IsMagnitude = true },
			new() { Name = "A1", InitialValue = 1e2, IsMagnitude = true },
			new() { Name = "T1", InitialValue = 5e0, Constraints = ParameterConstraints.Positive },
			new() { Name = "A2", InitialValue = 1e1, IsMagnitude = true },
			new() { Name = "T2", InitialValue = 5e1, Constraints = ParameterConstraints.Positive },
			new() { Name = "A3", InitialValue = 1e0, IsMagnitude = true },
			new() { Name = "T3", InitialValue = 5e2, Constraints = ParameterConstraints.Positive },
		];

		/// <inheritdoc/>
		public string Name => "Exp3";

		/// <inheritdoc/>
		public string Description => "3-component exponential model";

		/// <inheritdoc/>
		public string ExcelFormula => "[A0] + [A1] * EXP(-$X / [T1]) + [A2] * EXP(-$X / [T2]) + [A3] * EXP(-$X / [T3])";

		/// <inheritdoc/>
		public IReadOnlyList<Parameter> Parameters => parameters;

		/// <inheritdoc/>
		public bool XLogScale => false;

		/// <inheritdoc/>
		public bool YLogScale => true;

		/// <inheritdoc/>
		public Func<double, double> GetFunction(IReadOnlyList<double> parameters)
		{
			var a0 = parameters[0];
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];
			var a3 = parameters[5];
			var t3 = -1.0 / parameters[6];

			return x => a0 + a1 * MathUtil.FastExp(x * t1) + a2 * MathUtil.FastExp(x * t2) + a3 * MathUtil.FastExp(x * t3);
		} // public Func<double, double> GetFunction(IReadOnlyList<double> parameters)

		/// <inheritdoc/>
		public Func<AvxVector2048, AvxVector2048> GetVectorizedFunc(IReadOnlyList<double> parameters)
			=> x => 
			{
				var length = x.Length << 2;
				var temp = AvxVector2048.Create(length);
				var a0 = AvxVector2048.Create(length, parameters[0]);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				AvxVector2048.Multiply(x, t1, temp);     // temp = -x / t1
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t1)
				AvxVector2048.Multiply(temp, a1, temp);  // temp = a1 * exp(-x / t1)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a1 * exp(-x / t1)

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				AvxVector2048.Multiply(x, t2, temp);     // temp = -x / t2
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t2)
				AvxVector2048.Multiply(temp, a2, temp);  // temp = a2 * exp(-x / t2)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a2 * exp(-x / t2)

				var a3 = parameters[5];
				var t3 = -1.0 / parameters[6];
				AvxVector2048.Multiply(x, t3, temp);     // temp = -x / t3
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t3)
				AvxVector2048.Multiply(temp, a3, temp);  // temp = a3 * exp(-x / t3)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a3 * exp(-x / t3)

				return a0;
			};

		/// <inheritdoc/>
		public Action<double, double[]> GetDerivatives(IReadOnlyList<double> parameters)
		{
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];
			var a3 = parameters[5];
			var t3 = -1.0 / parameters[6];

			return (x, res) =>
			{
				var exp1 = MathUtil.FastExp(x * t1);
				var exp2 = MathUtil.FastExp(x * t2);
				var exp3 = MathUtil.FastExp(x * t3);

				var d_a0 = 1.0;
				var d_a1 = exp1;
				var d_t1 = a1 * x * exp1 * (t1 * t1);
				var d_a2 = exp2;
				var d_t2 = a2 * x * exp2 * (t2 * t2);
				var d_a3 = exp3;
				var d_t3 = a3 * x * exp3 * (t3 * t3);

				res[0] = d_a0;
				res[1] = d_a1;
				res[2] = d_t1;
				res[3] = d_a2;
				res[4] = d_t2;
				res[5] = d_a3;
				res[6] = d_t3;
			};
		} // public Action<double, double[]> GetDerivatives (IReadOnlyList<double>)

		/// <inheritdoc/>
		public Action<AvxVector2048, AvxVector2048[]> GetVectorizedDerivatives(IReadOnlyList<double> parameters)
			=> (x, res) =>
			{
				res[0].Load(1.0);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				// res[1] = exp(-x / t1)
				AvxVector2048.Multiply(x, t1, res[1]);
				AvxVector2048.Exp(res[1], res[1]);
				// res[2] = a1 * x * exp(-x / t1) / (t1 * t1)
				AvxVector2048.Multiply(res[1], a1 * t1 * t1, res[2]);
				AvxVector2048.Multiply(res[2], x, res[2]);

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				// res[3] = exp(-x / t2)
				AvxVector2048.Multiply(x, t2, res[3]);
				AvxVector2048.Exp(res[3], res[3]);
				// res[4] = a2 * x * exp(-x / t2) / (t2 * t2)
				AvxVector2048.Multiply(res[3], a2 * t2 * t2, res[4]);
				AvxVector2048.Multiply(res[4], x, res[4]);

				var a3 = parameters[5];
				var t3 = -1.0 / parameters[6];
				// res[5] = exp(-x / t3)
				AvxVector2048.Multiply(x, t3, res[5]);
				AvxVector2048.Exp(res[5], res[5]);
				// res[6] = a3 * x * exp(-x / t3) / (t3 * t3)
				AvxVector2048.Multiply(res[5], a3 * t3 * t3, res[6]);
				AvxVector2048.Multiply(res[6], x, res[6]);
			};
	} // internal partial class Exponential3 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
} // namespace TAFitting.Model.Exponential


namespace TAFitting.Model.Exponential
{

	/// <summary>
	/// Represents a 4-component exponential model.
	/// </summary>
	internal partial class Exponential4 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
	{
		private static readonly Parameter[] parameters = [
			new() { Name = "A0", IsMagnitude = true },
			new() { Name = "A1", InitialValue = 1e2, IsMagnitude = true },
			new() { Name = "T1", InitialValue = 5e0, Constraints = ParameterConstraints.Positive },
			new() { Name = "A2", InitialValue = 1e1, IsMagnitude = true },
			new() { Name = "T2", InitialValue = 5e1, Constraints = ParameterConstraints.Positive },
			new() { Name = "A3", InitialValue = 1e0, IsMagnitude = true },
			new() { Name = "T3", InitialValue = 5e2, Constraints = ParameterConstraints.Positive },
			new() { Name = "A4", InitialValue = 1e-1, IsMagnitude = true },
			new() { Name = "T4", InitialValue = 5e3, Constraints = ParameterConstraints.Positive },
		];

		/// <inheritdoc/>
		public string Name => "Exp4";

		/// <inheritdoc/>
		public string Description => "4-component exponential model";

		/// <inheritdoc/>
		public string ExcelFormula => "[A0] + [A1] * EXP(-$X / [T1]) + [A2] * EXP(-$X / [T2]) + [A3] * EXP(-$X / [T3]) + [A4] * EXP(-$X / [T4])";

		/// <inheritdoc/>
		public IReadOnlyList<Parameter> Parameters => parameters;

		/// <inheritdoc/>
		public bool XLogScale => false;

		/// <inheritdoc/>
		public bool YLogScale => true;

		/// <inheritdoc/>
		public Func<double, double> GetFunction(IReadOnlyList<double> parameters)
		{
			var a0 = parameters[0];
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];
			var a3 = parameters[5];
			var t3 = -1.0 / parameters[6];
			var a4 = parameters[7];
			var t4 = -1.0 / parameters[8];

			return x => a0 + a1 * MathUtil.FastExp(x * t1) + a2 * MathUtil.FastExp(x * t2) + a3 * MathUtil.FastExp(x * t3) + a4 * MathUtil.FastExp(x * t4);
		} // public Func<double, double> GetFunction(IReadOnlyList<double> parameters)

		/// <inheritdoc/>
		public Func<AvxVector2048, AvxVector2048> GetVectorizedFunc(IReadOnlyList<double> parameters)
			=> x => 
			{
				var length = x.Length << 2;
				var temp = AvxVector2048.Create(length);
				var a0 = AvxVector2048.Create(length, parameters[0]);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				AvxVector2048.Multiply(x, t1, temp);     // temp = -x / t1
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t1)
				AvxVector2048.Multiply(temp, a1, temp);  // temp = a1 * exp(-x / t1)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a1 * exp(-x / t1)

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				AvxVector2048.Multiply(x, t2, temp);     // temp = -x / t2
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t2)
				AvxVector2048.Multiply(temp, a2, temp);  // temp = a2 * exp(-x / t2)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a2 * exp(-x / t2)

				var a3 = parameters[5];
				var t3 = -1.0 / parameters[6];
				AvxVector2048.Multiply(x, t3, temp);     // temp = -x / t3
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t3)
				AvxVector2048.Multiply(temp, a3, temp);  // temp = a3 * exp(-x / t3)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a3 * exp(-x / t3)

				var a4 = parameters[7];
				var t4 = -1.0 / parameters[8];
				AvxVector2048.Multiply(x, t4, temp);     // temp = -x / t4
				AvxVector2048.Exp(temp, temp);           // temp = exp(-x / t4)
				AvxVector2048.Multiply(temp, a4, temp);  // temp = a4 * exp(-x / t4)
				AvxVector2048.Add(a0, temp, a0);         // a0 += a4 * exp(-x / t4)

				return a0;
			};

		/// <inheritdoc/>
		public Action<double, double[]> GetDerivatives(IReadOnlyList<double> parameters)
		{
			var a1 = parameters[1];
			var t1 = -1.0 / parameters[2];
			var a2 = parameters[3];
			var t2 = -1.0 / parameters[4];
			var a3 = parameters[5];
			var t3 = -1.0 / parameters[6];
			var a4 = parameters[7];
			var t4 = -1.0 / parameters[8];

			return (x, res) =>
			{
				var exp1 = MathUtil.FastExp(x * t1);
				var exp2 = MathUtil.FastExp(x * t2);
				var exp3 = MathUtil.FastExp(x * t3);
				var exp4 = MathUtil.FastExp(x * t4);

				var d_a0 = 1.0;
				var d_a1 = exp1;
				var d_t1 = a1 * x * exp1 * (t1 * t1);
				var d_a2 = exp2;
				var d_t2 = a2 * x * exp2 * (t2 * t2);
				var d_a3 = exp3;
				var d_t3 = a3 * x * exp3 * (t3 * t3);
				var d_a4 = exp4;
				var d_t4 = a4 * x * exp4 * (t4 * t4);

				res[0] = d_a0;
				res[1] = d_a1;
				res[2] = d_t1;
				res[3] = d_a2;
				res[4] = d_t2;
				res[5] = d_a3;
				res[6] = d_t3;
				res[7] = d_a4;
				res[8] = d_t4;
			};
		} // public Action<double, double[]> GetDerivatives (IReadOnlyList<double>)

		/// <inheritdoc/>
		public Action<AvxVector2048, AvxVector2048[]> GetVectorizedDerivatives(IReadOnlyList<double> parameters)
			=> (x, res) =>
			{
				res[0].Load(1.0);

				var a1 = parameters[1];
				var t1 = -1.0 / parameters[2];
				// res[1] = exp(-x / t1)
				AvxVector2048.Multiply(x, t1, res[1]);
				AvxVector2048.Exp(res[1], res[1]);
				// res[2] = a1 * x * exp(-x / t1) / (t1 * t1)
				AvxVector2048.Multiply(res[1], a1 * t1 * t1, res[2]);
				AvxVector2048.Multiply(res[2], x, res[2]);

				var a2 = parameters[3];
				var t2 = -1.0 / parameters[4];
				// res[3] = exp(-x / t2)
				AvxVector2048.Multiply(x, t2, res[3]);
				AvxVector2048.Exp(res[3], res[3]);
				// res[4] = a2 * x * exp(-x / t2) / (t2 * t2)
				AvxVector2048.Multiply(res[3], a2 * t2 * t2, res[4]);
				AvxVector2048.Multiply(res[4], x, res[4]);

				var a3 = parameters[5];
				var t3 = -1.0 / parameters[6];
				// res[5] = exp(-x / t3)
				AvxVector2048.Multiply(x, t3, res[5]);
				AvxVector2048.Exp(res[5], res[5]);
				// res[6] = a3 * x * exp(-x / t3) / (t3 * t3)
				AvxVector2048.Multiply(res[5], a3 * t3 * t3, res[6]);
				AvxVector2048.Multiply(res[6], x, res[6]);

				var a4 = parameters[7];
				var t4 = -1.0 / parameters[8];
				// res[7] = exp(-x / t4)
				AvxVector2048.Multiply(x, t4, res[7]);
				AvxVector2048.Exp(res[7], res[7]);
				// res[8] = a4 * x * exp(-x / t4) / (t4 * t4)
				AvxVector2048.Multiply(res[7], a4 * t4 * t4, res[8]);
				AvxVector2048.Multiply(res[8], x, res[8]);
			};
	} // internal partial class Exponential4 : IFittingModel, IAnalyticallyDifferentiable, IVectorizedModel<AvxVector2048>
} // namespace TAFitting.Model.Exponential

