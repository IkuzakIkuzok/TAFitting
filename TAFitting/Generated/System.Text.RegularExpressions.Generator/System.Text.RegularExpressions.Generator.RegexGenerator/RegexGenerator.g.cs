// <auto-generated/>
#nullable enable
#pragma warning disable CS0162 // Unreachable code
#pragma warning disable CS0164 // Unreferenced label
#pragma warning disable CS0219 // Variable assigned but never used

namespace TAFitting.Controls
{
    partial class UIUtils
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(?&lt;mantissa&gt;.*)(E(?&lt;exponent&gt;.*))</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ "mantissa" capture group.<br/>
        ///     ○ Match a character other than '\n' greedily any number of times.<br/>
        /// ○ 1st capture group.<br/>
        ///     ○ Match 'E'.<br/>
        ///     ○ "exponent" capture group.<br/>
        ///         ○ Match a character other than '\n' atomically any number of times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex RegexExpFormat() => global::System.Text.RegularExpressions.Generated.RegexExpFormat_0.Instance;
    }
}

namespace TAFitting.Data
{
    partial class Decays
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(\\d+).*</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Compiled</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ 1st capture group.<br/>
        ///     ○ Match a Unicode digit greedily at least once.<br/>
        /// ○ Match a character other than '\n' atomically any number of times.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex RegexWavelength() => global::System.Text.RegularExpressions.Generated.RegexWavelength_1.Instance;
    }
}

namespace TAFitting.Data
{
    partial class FileNameHandler
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>&lt;BASENAME(\\|[^|/]+/[^|/]*)*&gt;</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Compiled</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ Match the string "&lt;BASENAME".<br/>
        /// ○ Loop greedily any number of times.<br/>
        ///     ○ 1st capture group.<br/>
        ///         ○ Match '|'.<br/>
        ///         ○ Match a character in the set [^/|] atomically at least once.<br/>
        ///         ○ Match '/'.<br/>
        ///         ○ Match a character in the set [^/|] greedily any number of times.<br/>
        /// ○ Match '&gt;'.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex BasenamePattern() => global::System.Text.RegularExpressions.Generated.BasenamePattern_2.Instance;
    }
}

namespace TAFitting
{
    partial class StringComparer
    {
        /// <remarks>
        /// Pattern:<br/>
        /// <code>(\\D+|\\d+(\\.\\d+)?)</code><br/>
        /// Options:<br/>
        /// <code>RegexOptions.Compiled</code><br/>
        /// Explanation:<br/>
        /// <code>
        /// ○ 1st capture group.<br/>
        ///     ○ Match with 2 alternative expressions, atomically.<br/>
        ///         ○ Match any character other than a Unicode digit atomically at least once.<br/>
        ///         ○ Match a sequence of expressions.<br/>
        ///             ○ Match a Unicode digit greedily at least once.<br/>
        ///             ○ Optional (greedy).<br/>
        ///                 ○ 2nd capture group.<br/>
        ///                     ○ Match '.'.<br/>
        ///                     ○ Match a Unicode digit atomically at least once.<br/>
        /// </code>
        /// </remarks>
        [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
        private static partial global::System.Text.RegularExpressions.Regex NamePartsPattern() => global::System.Text.RegularExpressions.Generated.NamePartsPattern_3.Instance;
    }
}

namespace System.Text.RegularExpressions.Generated
{
    using System;
    using System.Buffers;
    using System.CodeDom.Compiler;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    using System.Runtime.CompilerServices;
    using System.Text.RegularExpressions;
    using System.Threading;

    /// <summary>Custom <see cref="Regex"/>-derived type for the RegexExpFormat method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    [SkipLocalsInit]
    file sealed class RegexExpFormat_0 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly RegexExpFormat_0 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private RegexExpFormat_0()
        {
            base.pattern = "(?<mantissa>.*)(E(?<exponent>.*))";
            base.roptions = RegexOptions.None;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.CapNames = new Hashtable { { "0", 0 } ,  { "1", 1 } ,  { "exponent", 3 } ,  { "mantissa", 2 }  };
            base.capslist = new string[] {"0", "1", "mantissa", "exponent" };
            base.capsize = 4;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [^\n].
                        // Find the next occurrence. If it can't be found, there's no match.
                        ReadOnlySpan<char> span = inputSpan.Slice(pos);
                        for (int i = 0; i < span.Length; i++)
                        {
                            if ((span[i] != '\n'))
                            {
                                base.runtextpos = pos + i;
                                return true;
                            }
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int capture_starting_pos1 = 0;
                    int capture_starting_pos2 = 0;
                    int charloop_capture_pos = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // "mantissa" capture group.
                    //{
                        capture_starting_pos = pos;
                        
                        // Match a character other than '\n' greedily any number of times.
                        //{
                            charloop_starting_pos = pos;
                            
                            int iteration = slice.IndexOf('\n');
                            if (iteration < 0)
                            {
                                iteration = slice.Length;
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                            
                            charloop_ending_pos = pos;
                            goto CharLoopEnd;
                            
                            CharLoopBacktrack:
                            UncaptureUntil(charloop_capture_pos);
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos >= charloop_ending_pos ||
                                (charloop_ending_pos = inputSpan.Slice(charloop_starting_pos, charloop_ending_pos - charloop_starting_pos).LastIndexOf('E')) < 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            charloop_ending_pos += charloop_starting_pos;
                            pos = charloop_ending_pos;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd:
                            charloop_capture_pos = base.Crawlpos();
                        //}
                        
                        base.Capture(2, capture_starting_pos, pos);
                        
                        goto CaptureSkipBacktrack;
                        
                        CaptureBacktrack:
                        goto CharLoopBacktrack;
                        
                        CaptureSkipBacktrack:;
                    //}
                    
                    // 1st capture group.
                    {
                        capture_starting_pos1 = pos;
                        
                        // Match 'E'.
                        if (slice.IsEmpty || slice[0] != 'E')
                        {
                            goto CaptureBacktrack;
                        }
                        
                        // "exponent" capture group.
                        {
                            pos++;
                            slice = inputSpan.Slice(pos);
                            capture_starting_pos2 = pos;
                            
                            // Match a character other than '\n' atomically any number of times.
                            {
                                int iteration1 = slice.IndexOf('\n');
                                if (iteration1 < 0)
                                {
                                    iteration1 = slice.Length;
                                }
                                
                                slice = slice.Slice(iteration1);
                                pos += iteration1;
                            }
                            
                            base.Capture(3, capture_starting_pos2, pos);
                        }
                        
                        base.Capture(1, capture_starting_pos1, pos);
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the RegexWavelength method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    [SkipLocalsInit]
    file sealed class RegexWavelength_1 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly RegexWavelength_1 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private RegexWavelength_1()
        {
            base.pattern = "(\\d+).*";
            base.roptions = RegexOptions.Compiled;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a Unicode digit.
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfAnyDigit();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int charloop_capture_pos = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // 1st capture group.
                    //{
                        capture_starting_pos = pos;
                        
                        // Match a Unicode digit greedily at least once.
                        //{
                            charloop_starting_pos = pos;
                            
                            int iteration = 0;
                            while ((uint)iteration < (uint)slice.Length && char.IsDigit(slice[iteration]))
                            {
                                iteration++;
                            }
                            
                            if (iteration == 0)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            
                            slice = slice.Slice(iteration);
                            pos += iteration;
                            
                            charloop_ending_pos = pos;
                            charloop_starting_pos++;
                            goto CharLoopEnd;
                            
                            CharLoopBacktrack:
                            UncaptureUntil(charloop_capture_pos);
                            
                            if (Utilities.s_hasTimeout)
                            {
                                base.CheckTimeout();
                            }
                            
                            if (charloop_starting_pos >= charloop_ending_pos)
                            {
                                UncaptureUntil(0);
                                return false; // The input didn't match.
                            }
                            pos = --charloop_ending_pos;
                            slice = inputSpan.Slice(pos);
                            
                            CharLoopEnd:
                            charloop_capture_pos = base.Crawlpos();
                        //}
                        
                        base.Capture(1, capture_starting_pos, pos);
                        
                        goto CaptureSkipBacktrack;
                        
                        CaptureBacktrack:
                        goto CharLoopBacktrack;
                        
                        CaptureSkipBacktrack:;
                    //}
                    
                    // Match a character other than '\n' atomically any number of times.
                    {
                        int iteration1 = slice.IndexOf('\n');
                        if (iteration1 < 0)
                        {
                            iteration1 = slice.Length;
                        }
                        
                        slice = slice.Slice(iteration1);
                        pos += iteration1;
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the BasenamePattern method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    [SkipLocalsInit]
    file sealed class BasenamePattern_2 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly BasenamePattern_2 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private BasenamePattern_2()
        {
            base.pattern = "<BASENAME(\\|[^|/]+/[^|/]*)*>";
            base.roptions = RegexOptions.Compiled;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 2;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Any possible match is at least 10 characters.
                    if (pos <= inputSpan.Length - 10)
                    {
                        // The pattern has the literal "<BASENAME" at the beginning of the pattern. Find the next occurrence.
                        // If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOf("<BASENAME");
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int loop_iteration = 0;
                    int stackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // Match the string "<BASENAME".
                    if (!slice.StartsWith("<BASENAME"))
                    {
                        UncaptureUntil(0);
                        return false; // The input didn't match.
                    }
                    
                    // Loop greedily any number of times.
                    //{
                        pos += 9;
                        slice = inputSpan.Slice(pos);
                        loop_iteration = 0;
                        
                        LoopBody:
                        Utilities.StackPush(ref base.runstack!, ref stackpos, base.Crawlpos(), pos);
                        
                        loop_iteration++;
                        
                        // 1st capture group.
                        //{
                            int capture_starting_pos = pos;
                            
                            // Match '|'.
                            if (slice.IsEmpty || slice[0] != '|')
                            {
                                goto LoopIterationNoMatch;
                            }
                            
                            // Match a character in the set [^/|] atomically at least once.
                            {
                                int iteration = slice.Slice(1).IndexOfAny('/', '|');
                                if (iteration < 0)
                                {
                                    iteration = slice.Length - 1;
                                }
                                
                                if (iteration == 0)
                                {
                                    goto LoopIterationNoMatch;
                                }
                                
                                slice = slice.Slice(iteration);
                                pos += iteration;
                            }
                            
                            // Match '/'.
                            if ((uint)slice.Length < 2 || slice[1] != '/')
                            {
                                goto LoopIterationNoMatch;
                            }
                            
                            // Match a character in the set [^/|] greedily any number of times.
                            //{
                                pos += 2;
                                slice = inputSpan.Slice(pos);
                                charloop_starting_pos = pos;
                                
                                int iteration1 = slice.IndexOfAny('/', '|');
                                if (iteration1 < 0)
                                {
                                    iteration1 = slice.Length;
                                }
                                
                                slice = slice.Slice(iteration1);
                                pos += iteration1;
                                
                                charloop_ending_pos = pos;
                                goto CharLoopEnd;
                                
                                CharLoopBacktrack:
                                UncaptureUntil(base.runstack![--stackpos]);
                                Utilities.StackPop(base.runstack!, ref stackpos, out charloop_ending_pos, out charloop_starting_pos);
                                
                                if (Utilities.s_hasTimeout)
                                {
                                    base.CheckTimeout();
                                }
                                
                                if (charloop_starting_pos >= charloop_ending_pos)
                                {
                                    goto LoopIterationNoMatch;
                                }
                                pos = --charloop_ending_pos;
                                slice = inputSpan.Slice(pos);
                                
                                CharLoopEnd:
                                Utilities.StackPush(ref base.runstack!, ref stackpos, charloop_starting_pos, charloop_ending_pos, base.Crawlpos());
                            //}
                            
                            base.Capture(1, capture_starting_pos, pos);
                            
                            Utilities.StackPush(ref base.runstack!, ref stackpos, capture_starting_pos);
                            goto CaptureSkipBacktrack;
                            
                            CaptureBacktrack:
                            capture_starting_pos = base.runstack![--stackpos];
                            goto CharLoopBacktrack;
                            
                            CaptureSkipBacktrack:;
                        //}
                        
                        
                        // The loop has no upper bound. Continue iterating greedily.
                        goto LoopBody;
                        
                        // The loop iteration failed. Put state back to the way it was before the iteration.
                        LoopIterationNoMatch:
                        if (--loop_iteration < 0)
                        {
                            // Unable to match the remainder of the expression after exhausting the loop.
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        pos = base.runstack![--stackpos];
                        UncaptureUntil(base.runstack![--stackpos]);
                        slice = inputSpan.Slice(pos);
                        goto LoopEnd;
                        
                        LoopBacktrack:
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                        
                        if (loop_iteration == 0)
                        {
                            // No iterations of the loop remain to backtrack into. Fail the loop.
                            UncaptureUntil(0);
                            return false; // The input didn't match.
                        }
                        goto CaptureBacktrack;
                        LoopEnd:;
                    //}
                    
                    // Match '>'.
                    if (slice.IsEmpty || slice[0] != '>')
                    {
                        goto LoopBacktrack;
                    }
                    
                    // The input matched.
                    pos++;
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Custom <see cref="Regex"/>-derived type for the NamePartsPattern method.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    [SkipLocalsInit]
    file sealed class NamePartsPattern_3 : Regex
    {
        /// <summary>Cached, thread-safe singleton instance.</summary>
        internal static readonly NamePartsPattern_3 Instance = new();
    
        /// <summary>Initializes the instance.</summary>
        private NamePartsPattern_3()
        {
            base.pattern = "(\\D+|\\d+(\\.\\d+)?)";
            base.roptions = RegexOptions.Compiled;
            ValidateMatchTimeout(Utilities.s_defaultTimeout);
            base.internalMatchTimeout = Utilities.s_defaultTimeout;
            base.factory = new RunnerFactory();
            base.capsize = 3;
        }
    
        /// <summary>Provides a factory for creating <see cref="RegexRunner"/> instances to be used by methods on <see cref="Regex"/>.</summary>
        private sealed class RunnerFactory : RegexRunnerFactory
        {
            /// <summary>Creates an instance of a <see cref="RegexRunner"/> used by methods on <see cref="Regex"/>.</summary>
            protected override RegexRunner CreateInstance() => new Runner();
        
            /// <summary>Provides the runner that contains the custom logic implementing the specified regular expression.</summary>
            private sealed class Runner : RegexRunner
            {
                /// <summary>Scan the <paramref name="inputSpan"/> starting from base.runtextstart for the next match.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                protected override void Scan(ReadOnlySpan<char> inputSpan)
                {
                    // Search until we can't find a valid starting position, we find a match, or we reach the end of the input.
                    while (TryFindNextPossibleStartingPosition(inputSpan) &&
                           !TryMatchAtCurrentPosition(inputSpan) &&
                           base.runtextpos != inputSpan.Length)
                    {
                        base.runtextpos++;
                        if (Utilities.s_hasTimeout)
                        {
                            base.CheckTimeout();
                        }
                    }
                }
        
                /// <summary>Search <paramref name="inputSpan"/> starting from base.runtextpos for the next location a match could possibly start.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if a possible match was found; false if no more matches are possible.</returns>
                private bool TryFindNextPossibleStartingPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    
                    // Empty matches aren't possible.
                    if ((uint)pos < (uint)inputSpan.Length)
                    {
                        // The pattern begins with a character in the set [\D\d].
                        // Find the next occurrence. If it can't be found, there's no match.
                        int i = inputSpan.Slice(pos).IndexOfNonAsciiOrAny_8340176EF7485D2D99A42D27C9C6E3F449E3B4F08B1114FBE7360A05B4E137A7();
                        if (i >= 0)
                        {
                            base.runtextpos = pos + i;
                            return true;
                        }
                    }
                    
                    // No match found.
                    base.runtextpos = inputSpan.Length;
                    return false;
                }
        
                /// <summary>Determine whether <paramref name="inputSpan"/> at base.runtextpos is a match for the regular expression.</summary>
                /// <param name="inputSpan">The text being scanned by the regular expression.</param>
                /// <returns>true if the regular expression matches at the current position; otherwise, false.</returns>
                private bool TryMatchAtCurrentPosition(ReadOnlySpan<char> inputSpan)
                {
                    int pos = base.runtextpos;
                    int matchStart = pos;
                    int capture_starting_pos = 0;
                    int charloop_capture_pos = 0;
                    int charloop_starting_pos = 0, charloop_ending_pos = 0;
                    int loop_iteration = 0;
                    int stackpos = 0;
                    int startingStackpos = 0;
                    ReadOnlySpan<char> slice = inputSpan.Slice(pos);
                    
                    // 1st capture group.
                    {
                        capture_starting_pos = pos;
                        
                        // Atomic group.
                        {
                            int atomic_stackpos = stackpos;
                            
                            // Match with 2 alternative expressions, atomically.
                            //{
                                int alternation_starting_pos = pos;
                                int alternation_starting_capturepos = base.Crawlpos();
                                
                                // Branch 0
                                {
                                    // Match any character other than a Unicode digit atomically at least once.
                                    {
                                        int iteration = 0;
                                        while ((uint)iteration < (uint)slice.Length && !char.IsDigit(slice[iteration]))
                                        {
                                            iteration++;
                                        }
                                        
                                        if (iteration == 0)
                                        {
                                            goto AlternationBranch;
                                        }
                                        
                                        slice = slice.Slice(iteration);
                                        pos += iteration;
                                    }
                                    
                                    goto AlternationMatch;
                                    
                                    AlternationBranch:
                                    pos = alternation_starting_pos;
                                    slice = inputSpan.Slice(pos);
                                    UncaptureUntil(alternation_starting_capturepos);
                                }
                                
                                // Branch 1
                                {
                                    // Match a Unicode digit greedily at least once.
                                    //{
                                        charloop_starting_pos = pos;
                                        
                                        int iteration1 = 0;
                                        while ((uint)iteration1 < (uint)slice.Length && char.IsDigit(slice[iteration1]))
                                        {
                                            iteration1++;
                                        }
                                        
                                        if (iteration1 == 0)
                                        {
                                            UncaptureUntil(0);
                                            return false; // The input didn't match.
                                        }
                                        
                                        slice = slice.Slice(iteration1);
                                        pos += iteration1;
                                        
                                        charloop_ending_pos = pos;
                                        charloop_starting_pos++;
                                        goto CharLoopEnd;
                                        
                                        CharLoopBacktrack:
                                        UncaptureUntil(charloop_capture_pos);
                                        
                                        if (Utilities.s_hasTimeout)
                                        {
                                            base.CheckTimeout();
                                        }
                                        
                                        if (charloop_starting_pos >= charloop_ending_pos)
                                        {
                                            UncaptureUntil(0);
                                            return false; // The input didn't match.
                                        }
                                        pos = --charloop_ending_pos;
                                        slice = inputSpan.Slice(pos);
                                        
                                        CharLoopEnd:
                                        charloop_capture_pos = base.Crawlpos();
                                    //}
                                    
                                    // Optional (greedy).
                                    {
                                        startingStackpos = stackpos;
                                        loop_iteration = 0;
                                        
                                        LoopBody:
                                        Utilities.StackPush(ref base.runstack!, ref stackpos, base.Crawlpos(), pos);
                                        
                                        loop_iteration++;
                                        
                                        // 2nd capture group.
                                        {
                                            int capture_starting_pos1 = pos;
                                            
                                            // Match '.'.
                                            if (slice.IsEmpty || slice[0] != '.')
                                            {
                                                goto LoopIterationNoMatch;
                                            }
                                            
                                            // Match a Unicode digit atomically at least once.
                                            {
                                                pos++;
                                                slice = inputSpan.Slice(pos);
                                                int iteration2 = 0;
                                                while ((uint)iteration2 < (uint)slice.Length && char.IsDigit(slice[iteration2]))
                                                {
                                                    iteration2++;
                                                }
                                                
                                                if (iteration2 == 0)
                                                {
                                                    goto LoopIterationNoMatch;
                                                }
                                                
                                                slice = slice.Slice(iteration2);
                                                pos += iteration2;
                                            }
                                            
                                            base.Capture(2, capture_starting_pos1, pos);
                                        }
                                        
                                        
                                        // The loop has an upper bound of 1. Continue iterating greedily if it hasn't yet been reached.
                                        if (loop_iteration == 0)
                                        {
                                            goto LoopBody;
                                        }
                                        goto LoopEnd;
                                        
                                        // The loop iteration failed. Put state back to the way it was before the iteration.
                                        LoopIterationNoMatch:
                                        if (--loop_iteration < 0)
                                        {
                                            // Unable to match the remainder of the expression after exhausting the loop.
                                            goto CharLoopBacktrack;
                                        }
                                        pos = base.runstack![--stackpos];
                                        UncaptureUntil(base.runstack![--stackpos]);
                                        slice = inputSpan.Slice(pos);
                                        LoopEnd:
                                        stackpos = startingStackpos; // Ensure any remaining backtracking state is removed.
                                    }
                                    
                                }
                                
                                AlternationMatch:;
                            //}
                            
                            stackpos = atomic_stackpos;
                        }
                        
                        base.Capture(1, capture_starting_pos, pos);
                    }
                    
                    // The input matched.
                    base.runtextpos = pos;
                    base.Capture(0, matchStart, pos);
                    return true;
                    
                    // <summary>Undo captures until it reaches the specified capture position.</summary>
                    [MethodImpl(MethodImplOptions.AggressiveInlining)]
                    void UncaptureUntil(int capturePosition)
                    {
                        while (base.Crawlpos() > capturePosition)
                        {
                            base.Uncapture();
                        }
                    }
                }
            }
        }

    }
    
    /// <summary>Helper methods used by generated <see cref="Regex"/>-derived implementations.</summary>
    [GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "8.0.10.36612")]
    file static class Utilities
    {
        /// <summary>Default timeout value set in <see cref="AppContext"/>, or <see cref="Regex.InfiniteMatchTimeout"/> if none was set.</summary>
        internal static readonly TimeSpan s_defaultTimeout = AppContext.GetData("REGEX_DEFAULT_MATCH_TIMEOUT") is TimeSpan timeout ? timeout : Regex.InfiniteMatchTimeout;
        
        /// <summary>Whether <see cref="s_defaultTimeout"/> is non-infinite.</summary>
        internal static readonly bool s_hasTimeout = s_defaultTimeout != Regex.InfiniteMatchTimeout;
        
        /// <summary>Finds the next index of any character that matches a Unicode digit.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int IndexOfAnyDigit(this ReadOnlySpan<char> span)
        {
            int i = span.IndexOfAnyExcept(Utilities.s_asciiExceptDigits);
            if ((uint)i < (uint)span.Length)
            {
                if (char.IsAscii(span[i]))
                {
                    return i;
                }
        
                do
                {
                    if (char.IsDigit(span[i]))
                    {
                        return i;
                    }
                    i++;
                }
                while ((uint)i < (uint)span.Length);
            }
        
            return -1;
        }
        
        /// <summary>Finds the next index of any character that matches a character in the set [\D\d].</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static int IndexOfNonAsciiOrAny_8340176EF7485D2D99A42D27C9C6E3F449E3B4F08B1114FBE7360A05B4E137A7(this ReadOnlySpan<char> span)
        {
            int i = span.IndexOfAnyExcept(Utilities.s_ascii_);
            if ((uint)i < (uint)span.Length)
            {
                if (char.IsAscii(span[i]))
                {
                    return i;
                }
        
                char ch;
                do
                {
                    if (((ch = span[i]) < 128 || RegexRunner.CharInClass((char)ch, "\0\0\u0002\ufff7\t")))
                    {
                        return i;
                    }
                    i++;
                }
                while ((uint)i < (uint)span.Length);
            }
        
            return -1;
        }
        
        /// <summary>Pops 2 values from the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPop(int[] stack, ref int pos, out int arg0, out int arg1)
        {
            arg0 = stack[--pos];
            arg1 = stack[--pos];
        }
        
        /// <summary>Pushes 1 value onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0)
        {
            // If there's space available for the value, store it.
            int[] s = stack;
            int p = pos;
            if ((uint)p < (uint)s.Length)
            {
                s[p] = arg0;
                pos++;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0);
        
            // <summary>Resize the backtracking stack array and push 1 value onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0)
            {
                Array.Resize(ref stack, (pos + 0) * 2);
                StackPush(ref stack, ref pos, arg0);
            }
        }
        
        /// <summary>Pushes 2 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1)
        {
            // If there's space available for all 2 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 1) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                pos += 2;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1);
        
            // <summary>Resize the backtracking stack array and push 2 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1)
            {
                Array.Resize(ref stack, (pos + 1) * 2);
                StackPush(ref stack, ref pos, arg0, arg1);
            }
        }
        
        /// <summary>Pushes 3 values onto the backtracking stack.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        internal static void StackPush(ref int[] stack, ref int pos, int arg0, int arg1, int arg2)
        {
            // If there's space available for all 3 values, store them.
            int[] s = stack;
            int p = pos;
            if ((uint)(p + 2) < (uint)s.Length)
            {
                s[p] = arg0;
                s[p + 1] = arg1;
                s[p + 2] = arg2;
                pos += 3;
                return;
            }
        
            // Otherwise, resize the stack to make room and try again.
            WithResize(ref stack, ref pos, arg0, arg1, arg2);
        
            // <summary>Resize the backtracking stack array and push 3 values onto the stack.</summary>
            [MethodImpl(MethodImplOptions.NoInlining)]
            static void WithResize(ref int[] stack, ref int pos, int arg0, int arg1, int arg2)
            {
                Array.Resize(ref stack, (pos + 2) * 2);
                StackPush(ref stack, ref pos, arg0, arg1, arg2);
            }
        }
        
        /// <summary>Supports searching for characters in or not in "\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&amp;'()*+,-./:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f".</summary>
        internal static readonly SearchValues<char> s_asciiExceptDigits = SearchValues.Create("\0\u0001\u0002\u0003\u0004\u0005\u0006\a\b\t\n\v\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\u007f");
        
        /// <summary>Supports searching for characters in or not in "".</summary>
        internal static readonly SearchValues<char> s_ascii_ = SearchValues.Create("");
    }
}
